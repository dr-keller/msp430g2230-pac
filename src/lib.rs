#![feature(abi_msp430_interrupt)]
#![doc = "Peripheral access API for MSP430G2230 microcontrollers (generated using svd2rust v0.37.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Generic peripheral accessor"]
    pub struct Periph<RB, const A: usize> {
        _marker: marker::PhantomData<RB>,
    }
    unsafe impl<RB, const A: usize> Send for Periph<RB, A> {}
    impl<RB, const A: usize> Periph<RB, A> {
        #[doc = "Pointer to the register block"]
        pub const PTR: *const RB = A as *const _;
        #[doc = "Return the pointer to the register block"]
        #[inline(always)]
        pub const fn ptr() -> *const RB {
            Self::PTR
        }
        #[doc = " Steal an instance of this peripheral"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
        #[doc = " that may race with any existing instances, for example by only"]
        #[doc = " accessing read-only or write-only registers, or by consuming the"]
        #[doc = " original peripheral and using critical sections to coordinate"]
        #[doc = " access between multiple new instances."]
        #[doc = ""]
        #[doc = " Additionally, other software such as HALs may rely on only one"]
        #[doc = " peripheral instance existing to ensure memory safety; ensure"]
        #[doc = " no stolen instances are passed to such software."]
        pub unsafe fn steal() -> Self {
            Self {
                _marker: marker::PhantomData,
            }
        }
    }
    impl<RB, const A: usize> core::ops::Deref for Periph<RB, A> {
        type Target = RB;
        #[inline(always)]
        fn deref(&self) -> &Self::Target {
            unsafe { &*Self::PTR }
        }
    }
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " `0`"]
        const ZERO: Self;
        #[doc = " `1`"]
        const ONE: Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                const ZERO: Self = 0;
                const ONE: Self = 1;
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + core::fmt::Debug + PartialEq + From<Self>;
    }
    #[doc = " Marker for fields with fixed values"]
    pub trait IsEnum: FieldSpec {}
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Is it safe to write any bits to register"]
        type Safety;
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux = Self::Ux::ZERO;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux = Self::Ux::ZERO;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `FieldWriter` you need to call field value setting method"]
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        #[must_use = "after creating `BitWriter` you need to call bit setting method"]
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    impl<REG: Writable> W<REG> {
        #[doc = " Writes raw bits to the register."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    impl<REG> W<REG>
    where
        REG: Writable<Safety = Safe>,
    {
        #[doc = " Writes raw bits to the register."]
        #[inline(always)]
        pub fn set(&mut self, bits: REG::Ux) -> &mut Self {
            self.bits = bits;
            self
        }
    }
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI: FieldSpec> core::fmt::Debug for FieldReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    impl<FI> core::fmt::Debug for BitReader<FI> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.bits, f)
        }
    }
    #[doc = " Marker for register/field writers which can take any value of specified width"]
    pub struct Safe;
    #[doc = " You should check that value is allowed to pass to register/field writer marked with this"]
    pub struct Unsafe;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct Range<const MIN: u64, const MAX: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeFrom<const MIN: u64>;
    #[doc = " Marker for field writers are safe to write in specified inclusive range"]
    pub struct RangeTo<const MAX: u64>;
    #[doc = " Write field Proxy"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe> =
        raw::FieldWriter<'a, REG, WI, FI, Safety>;
    impl<REG, const WI: u8, FI, Safety> FieldWriter<'_, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI, Safe>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64, const MAX: u64>
        FieldWriter<'a, REG, WI, FI, Range<MIN, MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN && value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MIN: u64> FieldWriter<'a, REG, WI, FI, RangeFrom<MIN>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value >= MIN);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, const MAX: u64> FieldWriter<'a, REG, WI, FI, RangeTo<MAX>>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
        u64: From<FI::Ux>,
    {
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn set(self, value: FI::Ux) -> &'a mut W<REG> {
            {
                let value = u64::from(value);
                assert!(value <= MAX);
            }
            unsafe { self.bits(value) }
        }
    }
    impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
    where
        REG: Writable + RegisterSpec,
        FI: IsEnum,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::ONE << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::ONE) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::ONE << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::ONE << self.o);
            self.w
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes bits to a `Writable` register and produce a value."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write_and(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[doc = ""]
        #[doc = " Values can be returned from the closure:"]
        #[doc = " ```ignore"]
        #[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn from_write<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                    | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F) -> REG::Ux
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            let value = f(&mut W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            })
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Writes 0 to a `Writable` register and produces a value."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn from_write_with_zero<F, T>(&self, f: F) -> T
        where
            F: FnOnce(&mut W<REG>) -> T,
        {
            let mut writer = W {
                bits: REG::Ux::ZERO,
                _reg: marker::PhantomData,
            };
            let result = f(&mut writer);
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F) -> REG::Ux
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            let value = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut W {
                    bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                },
            )
            .bits;
            self.register.set(value);
            value
        }
        #[doc = " Modifies the contents of the register by reading and then writing it"]
        #[doc = " and produces a value."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.modify(|r, w| {"]
        #[doc = "     let new_bits = r.bits() | 3;"]
        #[doc = "     unsafe {"]
        #[doc = "         w.bits(new_bits);"]
        #[doc = "     }"]
        #[doc = ""]
        #[doc = "     new_bits"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits)"]
        #[doc = "         .field2().set_bit()"]
        #[doc = "         .field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT);"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn from_modify<F, T>(&self, f: F) -> T
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> T,
        {
            let bits = self.register.get();
            let mut writer = W {
                bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                _reg: marker::PhantomData,
            };
            let result = f(
                &R {
                    bits,
                    _reg: marker::PhantomData,
                },
                &mut writer,
            );
            self.register.set(writer.bits);
            result
        }
    }
    impl<REG: Readable> core::fmt::Debug for crate::generic::Reg<REG>
    where
        R<REG>: core::fmt::Debug,
    {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            core::fmt::Debug::fmt(&self.read(), f)
        }
    }
}
#[cfg(feature = "rt")]
extern "msp430-interrupt" {
    fn PORT1();
    fn PORT2();
    fn USI();
    fn ADC10();
    fn TIMERA1();
    fn TIMERA0();
    fn WDT();
    fn NMI();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "msp430-interrupt" fn(),
    _reserved: u16,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
#[used]
pub static __INTERRUPTS: [Vector; 15] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: PORT1 },
    Vector { _handler: PORT2 },
    Vector { _handler: USI },
    Vector { _handler: ADC10 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: TIMERA1 },
    Vector { _handler: TIMERA0 },
    Vector { _handler: WDT },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: NMI },
];
#[doc = r"Enumeration of all the interrupts. This enum is seldom used in application or library crates. It is present primarily for documenting the device's implemented interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "2 - 0xFFE4 Port 1"]
    PORT1 = 2,
    #[doc = "3 - 0xFFE6 Port 2"]
    PORT2 = 3,
    #[doc = "4 - 0xFFE8 USI"]
    USI = 4,
    #[doc = "5 - 0xFFEA ADC10"]
    ADC10 = 5,
    #[doc = "8 - 0xFFF0 Timer A CC1, TA"]
    TIMERA1 = 8,
    #[doc = "9 - 0xFFF2 Timer A CC0"]
    TIMERA0 = 9,
    #[doc = "10 - 0xFFF4 Watchdog Timer"]
    WDT = 10,
    #[doc = "14 - 0xFFFC Non-maskable"]
    NMI = 14,
}
#[doc = "Special Function"]
pub type SpecialFunction = crate::Periph<special_function::RegisterBlock, 0>;
impl core::fmt::Debug for SpecialFunction {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SpecialFunction").finish()
    }
}
#[doc = "Special Function"]
pub mod special_function {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ie1: Ie1,
        _reserved1: [u8; 0x01],
        ifg1: Ifg1,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Interrupt Enable 1"]
        #[inline(always)]
        pub const fn ie1(&self) -> &Ie1 {
            &self.ie1
        }
        #[doc = "0x02 - Interrupt Flag 1"]
        #[inline(always)]
        pub const fn ifg1(&self) -> &Ifg1 {
            &self.ifg1
        }
    }
    #[doc = "IE1 (rw) register accessor: Interrupt Enable 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ie1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ie1`] module"]
    #[doc(alias = "IE1")]
    pub type Ie1 = crate::Reg<ie1::Ie1Spec>;
    #[doc = "Interrupt Enable 1"]
    pub mod ie1 {
        #[doc = "Register `IE1` reader"]
        pub type R = crate::R<Ie1Spec>;
        #[doc = "Register `IE1` writer"]
        pub type W = crate::W<Ie1Spec>;
        #[doc = "Field `WDTIE` reader - Watchdog Interrupt Enable"]
        pub type WdtieR = crate::BitReader;
        #[doc = "Field `WDTIE` writer - Watchdog Interrupt Enable"]
        pub type WdtieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OFIE` reader - Osc. Fault Interrupt Enable"]
        pub type OfieR = crate::BitReader;
        #[doc = "Field `OFIE` writer - Osc. Fault Interrupt Enable"]
        pub type OfieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NMIIE` reader - NMI Interrupt Enable"]
        pub type NmiieR = crate::BitReader;
        #[doc = "Field `NMIIE` writer - NMI Interrupt Enable"]
        pub type NmiieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ACCVIE` reader - Flash Access Violation Interrupt Enable"]
        pub type AccvieR = crate::BitReader;
        #[doc = "Field `ACCVIE` writer - Flash Access Violation Interrupt Enable"]
        pub type AccvieW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Watchdog Interrupt Enable"]
            #[inline(always)]
            pub fn wdtie(&self) -> WdtieR {
                WdtieR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Enable"]
            #[inline(always)]
            pub fn ofie(&self) -> OfieR {
                OfieR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 4 - NMI Interrupt Enable"]
            #[inline(always)]
            pub fn nmiie(&self) -> NmiieR {
                NmiieR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Flash Access Violation Interrupt Enable"]
            #[inline(always)]
            pub fn accvie(&self) -> AccvieR {
                AccvieR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Watchdog Interrupt Enable"]
            #[inline(always)]
            pub fn wdtie(&mut self) -> WdtieW<'_, Ie1Spec> {
                WdtieW::new(self, 0)
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Enable"]
            #[inline(always)]
            pub fn ofie(&mut self) -> OfieW<'_, Ie1Spec> {
                OfieW::new(self, 1)
            }
            #[doc = "Bit 4 - NMI Interrupt Enable"]
            #[inline(always)]
            pub fn nmiie(&mut self) -> NmiieW<'_, Ie1Spec> {
                NmiieW::new(self, 4)
            }
            #[doc = "Bit 5 - Flash Access Violation Interrupt Enable"]
            #[inline(always)]
            pub fn accvie(&mut self) -> AccvieW<'_, Ie1Spec> {
                AccvieW::new(self, 5)
            }
        }
        #[doc = "Interrupt Enable 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ie1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ie1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ie1Spec;
        impl crate::RegisterSpec for Ie1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ie1::R`](R) reader structure"]
        impl crate::Readable for Ie1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ie1::W`](W) writer structure"]
        impl crate::Writable for Ie1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IE1 to value 0"]
        impl crate::Resettable for Ie1Spec {}
    }
    #[doc = "IFG1 (rw) register accessor: Interrupt Flag 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ifg1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifg1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifg1`] module"]
    #[doc(alias = "IFG1")]
    pub type Ifg1 = crate::Reg<ifg1::Ifg1Spec>;
    #[doc = "Interrupt Flag 1"]
    pub mod ifg1 {
        #[doc = "Register `IFG1` reader"]
        pub type R = crate::R<Ifg1Spec>;
        #[doc = "Register `IFG1` writer"]
        pub type W = crate::W<Ifg1Spec>;
        #[doc = "Field `WDTIFG` reader - Watchdog Interrupt Flag"]
        pub type WdtifgR = crate::BitReader;
        #[doc = "Field `WDTIFG` writer - Watchdog Interrupt Flag"]
        pub type WdtifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OFIFG` reader - Osc. Fault Interrupt Flag"]
        pub type OfifgR = crate::BitReader;
        #[doc = "Field `OFIFG` writer - Osc. Fault Interrupt Flag"]
        pub type OfifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PORIFG` reader - Power On Interrupt Flag"]
        pub type PorifgR = crate::BitReader;
        #[doc = "Field `PORIFG` writer - Power On Interrupt Flag"]
        pub type PorifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RSTIFG` reader - Reset Interrupt Flag"]
        pub type RstifgR = crate::BitReader;
        #[doc = "Field `RSTIFG` writer - Reset Interrupt Flag"]
        pub type RstifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NMIIFG` reader - NMI Interrupt Flag"]
        pub type NmiifgR = crate::BitReader;
        #[doc = "Field `NMIIFG` writer - NMI Interrupt Flag"]
        pub type NmiifgW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Watchdog Interrupt Flag"]
            #[inline(always)]
            pub fn wdtifg(&self) -> WdtifgR {
                WdtifgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Flag"]
            #[inline(always)]
            pub fn ofifg(&self) -> OfifgR {
                OfifgR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Power On Interrupt Flag"]
            #[inline(always)]
            pub fn porifg(&self) -> PorifgR {
                PorifgR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Reset Interrupt Flag"]
            #[inline(always)]
            pub fn rstifg(&self) -> RstifgR {
                RstifgR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - NMI Interrupt Flag"]
            #[inline(always)]
            pub fn nmiifg(&self) -> NmiifgR {
                NmiifgR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Watchdog Interrupt Flag"]
            #[inline(always)]
            pub fn wdtifg(&mut self) -> WdtifgW<'_, Ifg1Spec> {
                WdtifgW::new(self, 0)
            }
            #[doc = "Bit 1 - Osc. Fault Interrupt Flag"]
            #[inline(always)]
            pub fn ofifg(&mut self) -> OfifgW<'_, Ifg1Spec> {
                OfifgW::new(self, 1)
            }
            #[doc = "Bit 2 - Power On Interrupt Flag"]
            #[inline(always)]
            pub fn porifg(&mut self) -> PorifgW<'_, Ifg1Spec> {
                PorifgW::new(self, 2)
            }
            #[doc = "Bit 3 - Reset Interrupt Flag"]
            #[inline(always)]
            pub fn rstifg(&mut self) -> RstifgW<'_, Ifg1Spec> {
                RstifgW::new(self, 3)
            }
            #[doc = "Bit 4 - NMI Interrupt Flag"]
            #[inline(always)]
            pub fn nmiifg(&mut self) -> NmiifgW<'_, Ifg1Spec> {
                NmiifgW::new(self, 4)
            }
        }
        #[doc = "Interrupt Flag 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ifg1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifg1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ifg1Spec;
        impl crate::RegisterSpec for Ifg1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ifg1::R`](R) reader structure"]
        impl crate::Readable for Ifg1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ifg1::W`](W) writer structure"]
        impl crate::Writable for Ifg1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IFG1 to value 0"]
        impl crate::Resettable for Ifg1Spec {}
    }
}
#[doc = "Port 1/2"]
pub type Port1_2 = crate::Periph<port_1_2::RegisterBlock, 0x20>;
impl core::fmt::Debug for Port1_2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Port1_2").finish()
    }
}
#[doc = "Port 1/2"]
pub mod port_1_2 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        p1in: P1in,
        p1out: P1out,
        p1dir: P1dir,
        p1ifg: P1ifg,
        p1ies: P1ies,
        p1ie: P1ie,
        p1sel: P1sel,
        p1ren: P1ren,
        p2in: P2in,
        p2out: P2out,
        p2dir: P2dir,
        p2ifg: P2ifg,
        p2ies: P2ies,
        p2ie: P2ie,
        p2sel: P2sel,
        p2ren: P2ren,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Port 1 Input"]
        #[inline(always)]
        pub const fn p1in(&self) -> &P1in {
            &self.p1in
        }
        #[doc = "0x01 - Port 1 Output"]
        #[inline(always)]
        pub const fn p1out(&self) -> &P1out {
            &self.p1out
        }
        #[doc = "0x02 - Port 1 Direction"]
        #[inline(always)]
        pub const fn p1dir(&self) -> &P1dir {
            &self.p1dir
        }
        #[doc = "0x03 - Port 1 Interrupt Flag"]
        #[inline(always)]
        pub const fn p1ifg(&self) -> &P1ifg {
            &self.p1ifg
        }
        #[doc = "0x04 - Port 1 Interrupt Edge Select"]
        #[inline(always)]
        pub const fn p1ies(&self) -> &P1ies {
            &self.p1ies
        }
        #[doc = "0x05 - Port 1 Interrupt Enable"]
        #[inline(always)]
        pub const fn p1ie(&self) -> &P1ie {
            &self.p1ie
        }
        #[doc = "0x06 - Port 1 Selection"]
        #[inline(always)]
        pub const fn p1sel(&self) -> &P1sel {
            &self.p1sel
        }
        #[doc = "0x07 - Port 1 Resistor Enable"]
        #[inline(always)]
        pub const fn p1ren(&self) -> &P1ren {
            &self.p1ren
        }
        #[doc = "0x08 - Port 2 Input"]
        #[inline(always)]
        pub const fn p2in(&self) -> &P2in {
            &self.p2in
        }
        #[doc = "0x09 - Port 2 Output"]
        #[inline(always)]
        pub const fn p2out(&self) -> &P2out {
            &self.p2out
        }
        #[doc = "0x0a - Port 2 Direction"]
        #[inline(always)]
        pub const fn p2dir(&self) -> &P2dir {
            &self.p2dir
        }
        #[doc = "0x0b - Port 2 Interrupt Flag"]
        #[inline(always)]
        pub const fn p2ifg(&self) -> &P2ifg {
            &self.p2ifg
        }
        #[doc = "0x0c - Port 2 Interrupt Edge Select"]
        #[inline(always)]
        pub const fn p2ies(&self) -> &P2ies {
            &self.p2ies
        }
        #[doc = "0x0d - Port 2 Interrupt Enable"]
        #[inline(always)]
        pub const fn p2ie(&self) -> &P2ie {
            &self.p2ie
        }
        #[doc = "0x0e - Port 2 Selection"]
        #[inline(always)]
        pub const fn p2sel(&self) -> &P2sel {
            &self.p2sel
        }
        #[doc = "0x0f - Port 2 Resistor Enable"]
        #[inline(always)]
        pub const fn p2ren(&self) -> &P2ren {
            &self.p2ren
        }
    }
    #[doc = "P1IN (rw) register accessor: Port 1 Input\n\nYou can [`read`](crate::Reg::read) this register and get [`p1in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1in`] module"]
    #[doc(alias = "P1IN")]
    pub type P1in = crate::Reg<p1in::P1inSpec>;
    #[doc = "Port 1 Input"]
    pub mod p1in {
        #[doc = "Register `P1IN` reader"]
        pub type R = crate::R<P1inSpec>;
        #[doc = "Register `P1IN` writer"]
        pub type W = crate::W<P1inSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1inSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1inSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1inSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1inSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1inSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1inSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1inSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1inSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Input\n\nYou can [`read`](crate::Reg::read) this register and get [`p1in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1inSpec;
        impl crate::RegisterSpec for P1inSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1in::R`](R) reader structure"]
        impl crate::Readable for P1inSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1in::W`](W) writer structure"]
        impl crate::Writable for P1inSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1IN to value 0"]
        impl crate::Resettable for P1inSpec {}
    }
    #[doc = "P1OUT (rw) register accessor: Port 1 Output\n\nYou can [`read`](crate::Reg::read) this register and get [`p1out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1out`] module"]
    #[doc(alias = "P1OUT")]
    pub type P1out = crate::Reg<p1out::P1outSpec>;
    #[doc = "Port 1 Output"]
    pub mod p1out {
        #[doc = "Register `P1OUT` reader"]
        pub type R = crate::R<P1outSpec>;
        #[doc = "Register `P1OUT` writer"]
        pub type W = crate::W<P1outSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1outSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1outSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1outSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1outSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1outSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1outSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1outSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1outSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Output\n\nYou can [`read`](crate::Reg::read) this register and get [`p1out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1outSpec;
        impl crate::RegisterSpec for P1outSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1out::R`](R) reader structure"]
        impl crate::Readable for P1outSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1out::W`](W) writer structure"]
        impl crate::Writable for P1outSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1OUT to value 0"]
        impl crate::Resettable for P1outSpec {}
    }
    #[doc = "P1DIR (rw) register accessor: Port 1 Direction\n\nYou can [`read`](crate::Reg::read) this register and get [`p1dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1dir`] module"]
    #[doc(alias = "P1DIR")]
    pub type P1dir = crate::Reg<p1dir::P1dirSpec>;
    #[doc = "Port 1 Direction"]
    pub mod p1dir {
        #[doc = "Register `P1DIR` reader"]
        pub type R = crate::R<P1dirSpec>;
        #[doc = "Register `P1DIR` writer"]
        pub type W = crate::W<P1dirSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1dirSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1dirSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1dirSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1dirSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1dirSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1dirSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1dirSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1dirSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Direction\n\nYou can [`read`](crate::Reg::read) this register and get [`p1dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1dirSpec;
        impl crate::RegisterSpec for P1dirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1dir::R`](R) reader structure"]
        impl crate::Readable for P1dirSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1dir::W`](W) writer structure"]
        impl crate::Writable for P1dirSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1DIR to value 0"]
        impl crate::Resettable for P1dirSpec {}
    }
    #[doc = "P1IFG (rw) register accessor: Port 1 Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ifg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ifg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1ifg`] module"]
    #[doc(alias = "P1IFG")]
    pub type P1ifg = crate::Reg<p1ifg::P1ifgSpec>;
    #[doc = "Port 1 Interrupt Flag"]
    pub mod p1ifg {
        #[doc = "Register `P1IFG` reader"]
        pub type R = crate::R<P1ifgSpec>;
        #[doc = "Register `P1IFG` writer"]
        pub type W = crate::W<P1ifgSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1ifgSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1ifgSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1ifgSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1ifgSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1ifgSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1ifgSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1ifgSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1ifgSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ifg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ifg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1ifgSpec;
        impl crate::RegisterSpec for P1ifgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1ifg::R`](R) reader structure"]
        impl crate::Readable for P1ifgSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1ifg::W`](W) writer structure"]
        impl crate::Writable for P1ifgSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1IFG to value 0"]
        impl crate::Resettable for P1ifgSpec {}
    }
    #[doc = "P1IES (rw) register accessor: Port 1 Interrupt Edge Select\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ies::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ies::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1ies`] module"]
    #[doc(alias = "P1IES")]
    pub type P1ies = crate::Reg<p1ies::P1iesSpec>;
    #[doc = "Port 1 Interrupt Edge Select"]
    pub mod p1ies {
        #[doc = "Register `P1IES` reader"]
        pub type R = crate::R<P1iesSpec>;
        #[doc = "Register `P1IES` writer"]
        pub type W = crate::W<P1iesSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1iesSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1iesSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1iesSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1iesSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1iesSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1iesSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1iesSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1iesSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Interrupt Edge Select\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ies::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ies::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1iesSpec;
        impl crate::RegisterSpec for P1iesSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1ies::R`](R) reader structure"]
        impl crate::Readable for P1iesSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1ies::W`](W) writer structure"]
        impl crate::Writable for P1iesSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1IES to value 0"]
        impl crate::Resettable for P1iesSpec {}
    }
    #[doc = "P1IE (rw) register accessor: Port 1 Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1ie`] module"]
    #[doc(alias = "P1IE")]
    pub type P1ie = crate::Reg<p1ie::P1ieSpec>;
    #[doc = "Port 1 Interrupt Enable"]
    pub mod p1ie {
        #[doc = "Register `P1IE` reader"]
        pub type R = crate::R<P1ieSpec>;
        #[doc = "Register `P1IE` writer"]
        pub type W = crate::W<P1ieSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1ieSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1ieSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1ieSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1ieSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1ieSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1ieSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1ieSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1ieSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1ieSpec;
        impl crate::RegisterSpec for P1ieSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1ie::R`](R) reader structure"]
        impl crate::Readable for P1ieSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1ie::W`](W) writer structure"]
        impl crate::Writable for P1ieSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1IE to value 0"]
        impl crate::Resettable for P1ieSpec {}
    }
    #[doc = "P1SEL (rw) register accessor: Port 1 Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`p1sel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1sel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1sel`] module"]
    #[doc(alias = "P1SEL")]
    pub type P1sel = crate::Reg<p1sel::P1selSpec>;
    #[doc = "Port 1 Selection"]
    pub mod p1sel {
        #[doc = "Register `P1SEL` reader"]
        pub type R = crate::R<P1selSpec>;
        #[doc = "Register `P1SEL` writer"]
        pub type W = crate::W<P1selSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1selSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1selSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1selSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1selSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1selSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1selSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1selSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1selSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`p1sel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1sel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1selSpec;
        impl crate::RegisterSpec for P1selSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1sel::R`](R) reader structure"]
        impl crate::Readable for P1selSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1sel::W`](W) writer structure"]
        impl crate::Writable for P1selSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1SEL to value 0"]
        impl crate::Resettable for P1selSpec {}
    }
    #[doc = "P1REN (rw) register accessor: Port 1 Resistor Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ren::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ren::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p1ren`] module"]
    #[doc(alias = "P1REN")]
    pub type P1ren = crate::Reg<p1ren::P1renSpec>;
    #[doc = "Port 1 Resistor Enable"]
    pub mod p1ren {
        #[doc = "Register `P1REN` reader"]
        pub type R = crate::R<P1renSpec>;
        #[doc = "Register `P1REN` writer"]
        pub type W = crate::W<P1renSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P1renSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P1renSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P1renSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P1renSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P1renSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P1renSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P1renSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P1renSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 1 Resistor Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p1ren::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p1ren::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P1renSpec;
        impl crate::RegisterSpec for P1renSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p1ren::R`](R) reader structure"]
        impl crate::Readable for P1renSpec {}
        #[doc = "`write(|w| ..)` method takes [`p1ren::W`](W) writer structure"]
        impl crate::Writable for P1renSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P1REN to value 0"]
        impl crate::Resettable for P1renSpec {}
    }
    #[doc = "P2IN (rw) register accessor: Port 2 Input\n\nYou can [`read`](crate::Reg::read) this register and get [`p2in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2in`] module"]
    #[doc(alias = "P2IN")]
    pub type P2in = crate::Reg<p2in::P2inSpec>;
    #[doc = "Port 2 Input"]
    pub mod p2in {
        #[doc = "Register `P2IN` reader"]
        pub type R = crate::R<P2inSpec>;
        #[doc = "Register `P2IN` writer"]
        pub type W = crate::W<P2inSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2inSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2inSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2inSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2inSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2inSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2inSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2inSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2inSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Input\n\nYou can [`read`](crate::Reg::read) this register and get [`p2in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2inSpec;
        impl crate::RegisterSpec for P2inSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2in::R`](R) reader structure"]
        impl crate::Readable for P2inSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2in::W`](W) writer structure"]
        impl crate::Writable for P2inSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2IN to value 0"]
        impl crate::Resettable for P2inSpec {}
    }
    #[doc = "P2OUT (rw) register accessor: Port 2 Output\n\nYou can [`read`](crate::Reg::read) this register and get [`p2out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2out`] module"]
    #[doc(alias = "P2OUT")]
    pub type P2out = crate::Reg<p2out::P2outSpec>;
    #[doc = "Port 2 Output"]
    pub mod p2out {
        #[doc = "Register `P2OUT` reader"]
        pub type R = crate::R<P2outSpec>;
        #[doc = "Register `P2OUT` writer"]
        pub type W = crate::W<P2outSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2outSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2outSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2outSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2outSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2outSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2outSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2outSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2outSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Output\n\nYou can [`read`](crate::Reg::read) this register and get [`p2out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2outSpec;
        impl crate::RegisterSpec for P2outSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2out::R`](R) reader structure"]
        impl crate::Readable for P2outSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2out::W`](W) writer structure"]
        impl crate::Writable for P2outSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2OUT to value 0"]
        impl crate::Resettable for P2outSpec {}
    }
    #[doc = "P2DIR (rw) register accessor: Port 2 Direction\n\nYou can [`read`](crate::Reg::read) this register and get [`p2dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2dir`] module"]
    #[doc(alias = "P2DIR")]
    pub type P2dir = crate::Reg<p2dir::P2dirSpec>;
    #[doc = "Port 2 Direction"]
    pub mod p2dir {
        #[doc = "Register `P2DIR` reader"]
        pub type R = crate::R<P2dirSpec>;
        #[doc = "Register `P2DIR` writer"]
        pub type W = crate::W<P2dirSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2dirSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2dirSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2dirSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2dirSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2dirSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2dirSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2dirSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2dirSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Direction\n\nYou can [`read`](crate::Reg::read) this register and get [`p2dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2dirSpec;
        impl crate::RegisterSpec for P2dirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2dir::R`](R) reader structure"]
        impl crate::Readable for P2dirSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2dir::W`](W) writer structure"]
        impl crate::Writable for P2dirSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2DIR to value 0"]
        impl crate::Resettable for P2dirSpec {}
    }
    #[doc = "P2IFG (rw) register accessor: Port 2 Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ifg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ifg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2ifg`] module"]
    #[doc(alias = "P2IFG")]
    pub type P2ifg = crate::Reg<p2ifg::P2ifgSpec>;
    #[doc = "Port 2 Interrupt Flag"]
    pub mod p2ifg {
        #[doc = "Register `P2IFG` reader"]
        pub type R = crate::R<P2ifgSpec>;
        #[doc = "Register `P2IFG` writer"]
        pub type W = crate::W<P2ifgSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2ifgSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2ifgSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2ifgSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2ifgSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2ifgSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2ifgSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2ifgSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2ifgSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Interrupt Flag\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ifg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ifg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2ifgSpec;
        impl crate::RegisterSpec for P2ifgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2ifg::R`](R) reader structure"]
        impl crate::Readable for P2ifgSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2ifg::W`](W) writer structure"]
        impl crate::Writable for P2ifgSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2IFG to value 0"]
        impl crate::Resettable for P2ifgSpec {}
    }
    #[doc = "P2IES (rw) register accessor: Port 2 Interrupt Edge Select\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ies::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ies::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2ies`] module"]
    #[doc(alias = "P2IES")]
    pub type P2ies = crate::Reg<p2ies::P2iesSpec>;
    #[doc = "Port 2 Interrupt Edge Select"]
    pub mod p2ies {
        #[doc = "Register `P2IES` reader"]
        pub type R = crate::R<P2iesSpec>;
        #[doc = "Register `P2IES` writer"]
        pub type W = crate::W<P2iesSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2iesSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2iesSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2iesSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2iesSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2iesSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2iesSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2iesSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2iesSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Interrupt Edge Select\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ies::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ies::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2iesSpec;
        impl crate::RegisterSpec for P2iesSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2ies::R`](R) reader structure"]
        impl crate::Readable for P2iesSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2ies::W`](W) writer structure"]
        impl crate::Writable for P2iesSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2IES to value 0"]
        impl crate::Resettable for P2iesSpec {}
    }
    #[doc = "P2IE (rw) register accessor: Port 2 Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2ie`] module"]
    #[doc(alias = "P2IE")]
    pub type P2ie = crate::Reg<p2ie::P2ieSpec>;
    #[doc = "Port 2 Interrupt Enable"]
    pub mod p2ie {
        #[doc = "Register `P2IE` reader"]
        pub type R = crate::R<P2ieSpec>;
        #[doc = "Register `P2IE` writer"]
        pub type W = crate::W<P2ieSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2ieSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2ieSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2ieSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2ieSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2ieSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2ieSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2ieSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2ieSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Interrupt Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2ieSpec;
        impl crate::RegisterSpec for P2ieSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2ie::R`](R) reader structure"]
        impl crate::Readable for P2ieSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2ie::W`](W) writer structure"]
        impl crate::Writable for P2ieSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2IE to value 0"]
        impl crate::Resettable for P2ieSpec {}
    }
    #[doc = "P2SEL (rw) register accessor: Port 2 Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`p2sel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2sel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2sel`] module"]
    #[doc(alias = "P2SEL")]
    pub type P2sel = crate::Reg<p2sel::P2selSpec>;
    #[doc = "Port 2 Selection"]
    pub mod p2sel {
        #[doc = "Register `P2SEL` reader"]
        pub type R = crate::R<P2selSpec>;
        #[doc = "Register `P2SEL` writer"]
        pub type W = crate::W<P2selSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2selSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2selSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2selSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2selSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2selSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2selSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2selSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2selSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Selection\n\nYou can [`read`](crate::Reg::read) this register and get [`p2sel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2sel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2selSpec;
        impl crate::RegisterSpec for P2selSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2sel::R`](R) reader structure"]
        impl crate::Readable for P2selSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2sel::W`](W) writer structure"]
        impl crate::Writable for P2selSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2SEL to value 0"]
        impl crate::Resettable for P2selSpec {}
    }
    #[doc = "P2REN (rw) register accessor: Port 2 Resistor Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ren::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ren::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@p2ren`] module"]
    #[doc(alias = "P2REN")]
    pub type P2ren = crate::Reg<p2ren::P2renSpec>;
    #[doc = "Port 2 Resistor Enable"]
    pub mod p2ren {
        #[doc = "Register `P2REN` reader"]
        pub type R = crate::R<P2renSpec>;
        #[doc = "Register `P2REN` writer"]
        pub type W = crate::W<P2renSpec>;
        #[doc = "Field `P0` reader - P0"]
        pub type P0R = crate::BitReader;
        #[doc = "Field `P0` writer - P0"]
        pub type P0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P1` reader - P1"]
        pub type P1R = crate::BitReader;
        #[doc = "Field `P1` writer - P1"]
        pub type P1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P2` reader - P2"]
        pub type P2R = crate::BitReader;
        #[doc = "Field `P2` writer - P2"]
        pub type P2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P3` reader - P3"]
        pub type P3R = crate::BitReader;
        #[doc = "Field `P3` writer - P3"]
        pub type P3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P4` reader - P4"]
        pub type P4R = crate::BitReader;
        #[doc = "Field `P4` writer - P4"]
        pub type P4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P5` reader - P5"]
        pub type P5R = crate::BitReader;
        #[doc = "Field `P5` writer - P5"]
        pub type P5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P6` reader - P6"]
        pub type P6R = crate::BitReader;
        #[doc = "Field `P6` writer - P6"]
        pub type P6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `P7` reader - P7"]
        pub type P7R = crate::BitReader;
        #[doc = "Field `P7` writer - P7"]
        pub type P7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&self) -> P0R {
                P0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&self) -> P1R {
                P1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&self) -> P2R {
                P2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&self) -> P3R {
                P3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&self) -> P4R {
                P4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&self) -> P5R {
                P5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&self) -> P6R {
                P6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&self) -> P7R {
                P7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - P0"]
            #[inline(always)]
            pub fn p0(&mut self) -> P0W<'_, P2renSpec> {
                P0W::new(self, 0)
            }
            #[doc = "Bit 1 - P1"]
            #[inline(always)]
            pub fn p1(&mut self) -> P1W<'_, P2renSpec> {
                P1W::new(self, 1)
            }
            #[doc = "Bit 2 - P2"]
            #[inline(always)]
            pub fn p2(&mut self) -> P2W<'_, P2renSpec> {
                P2W::new(self, 2)
            }
            #[doc = "Bit 3 - P3"]
            #[inline(always)]
            pub fn p3(&mut self) -> P3W<'_, P2renSpec> {
                P3W::new(self, 3)
            }
            #[doc = "Bit 4 - P4"]
            #[inline(always)]
            pub fn p4(&mut self) -> P4W<'_, P2renSpec> {
                P4W::new(self, 4)
            }
            #[doc = "Bit 5 - P5"]
            #[inline(always)]
            pub fn p5(&mut self) -> P5W<'_, P2renSpec> {
                P5W::new(self, 5)
            }
            #[doc = "Bit 6 - P6"]
            #[inline(always)]
            pub fn p6(&mut self) -> P6W<'_, P2renSpec> {
                P6W::new(self, 6)
            }
            #[doc = "Bit 7 - P7"]
            #[inline(always)]
            pub fn p7(&mut self) -> P7W<'_, P2renSpec> {
                P7W::new(self, 7)
            }
        }
        #[doc = "Port 2 Resistor Enable\n\nYou can [`read`](crate::Reg::read) this register and get [`p2ren::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`p2ren::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct P2renSpec;
        impl crate::RegisterSpec for P2renSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`p2ren::R`](R) reader structure"]
        impl crate::Readable for P2renSpec {}
        #[doc = "`write(|w| ..)` method takes [`p2ren::W`](W) writer structure"]
        impl crate::Writable for P2renSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets P2REN to value 0"]
        impl crate::Resettable for P2renSpec {}
    }
}
#[doc = "ADC10"]
pub type Adc10 = crate::Periph<adc10::RegisterBlock, 0x48>;
impl core::fmt::Debug for Adc10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc10").finish()
    }
}
#[doc = "ADC10"]
pub mod adc10 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        adc10dtc0: Adc10dtc0,
        adc10dtc1: Adc10dtc1,
        adc10ae0: Adc10ae0,
        _reserved3: [u8; 0x0165],
        adc10ctl0: Adc10ctl0,
        adc10ctl1: Adc10ctl1,
        adc10mem: Adc10mem,
        _reserved6: [u8; 0x06],
        adc10sa: Adc10sa,
    }
    impl RegisterBlock {
        #[doc = "0x00 - ADC10 Data Transfer Control 0"]
        #[inline(always)]
        pub const fn adc10dtc0(&self) -> &Adc10dtc0 {
            &self.adc10dtc0
        }
        #[doc = "0x01 - ADC10 Data Transfer Control 1"]
        #[inline(always)]
        pub const fn adc10dtc1(&self) -> &Adc10dtc1 {
            &self.adc10dtc1
        }
        #[doc = "0x02 - ADC10 Analog Enable 0"]
        #[inline(always)]
        pub const fn adc10ae0(&self) -> &Adc10ae0 {
            &self.adc10ae0
        }
        #[doc = "0x168 - ADC10 Control 0"]
        #[inline(always)]
        pub const fn adc10ctl0(&self) -> &Adc10ctl0 {
            &self.adc10ctl0
        }
        #[doc = "0x16a - ADC10 Control 1"]
        #[inline(always)]
        pub const fn adc10ctl1(&self) -> &Adc10ctl1 {
            &self.adc10ctl1
        }
        #[doc = "0x16c - ADC10 Memory"]
        #[inline(always)]
        pub const fn adc10mem(&self) -> &Adc10mem {
            &self.adc10mem
        }
        #[doc = "0x174 - ADC10 Data Transfer Start Address"]
        #[inline(always)]
        pub const fn adc10sa(&self) -> &Adc10sa {
            &self.adc10sa
        }
    }
    #[doc = "ADC10DTC0 (rw) register accessor: ADC10 Data Transfer Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10dtc0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10dtc0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10dtc0`] module"]
    #[doc(alias = "ADC10DTC0")]
    pub type Adc10dtc0 = crate::Reg<adc10dtc0::Adc10dtc0Spec>;
    #[doc = "ADC10 Data Transfer Control 0"]
    pub mod adc10dtc0 {
        #[doc = "Register `ADC10DTC0` reader"]
        pub type R = crate::R<Adc10dtc0Spec>;
        #[doc = "Register `ADC10DTC0` writer"]
        pub type W = crate::W<Adc10dtc0Spec>;
        #[doc = "Field `ADC10FETCH` reader - This bit should normally be reset"]
        pub type Adc10fetchR = crate::BitReader;
        #[doc = "Field `ADC10FETCH` writer - This bit should normally be reset"]
        pub type Adc10fetchW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10B1` reader - ADC10 block one"]
        pub type Adc10b1R = crate::BitReader;
        #[doc = "Field `ADC10B1` writer - ADC10 block one"]
        pub type Adc10b1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10CT` reader - ADC10 continuous transfer"]
        pub type Adc10ctR = crate::BitReader;
        #[doc = "Field `ADC10CT` writer - ADC10 continuous transfer"]
        pub type Adc10ctW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10TB` reader - ADC10 two-block mode"]
        pub type Adc10tbR = crate::BitReader;
        #[doc = "Field `ADC10TB` writer - ADC10 two-block mode"]
        pub type Adc10tbW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - This bit should normally be reset"]
            #[inline(always)]
            pub fn adc10fetch(&self) -> Adc10fetchR {
                Adc10fetchR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ADC10 block one"]
            #[inline(always)]
            pub fn adc10b1(&self) -> Adc10b1R {
                Adc10b1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - ADC10 continuous transfer"]
            #[inline(always)]
            pub fn adc10ct(&self) -> Adc10ctR {
                Adc10ctR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - ADC10 two-block mode"]
            #[inline(always)]
            pub fn adc10tb(&self) -> Adc10tbR {
                Adc10tbR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - This bit should normally be reset"]
            #[inline(always)]
            pub fn adc10fetch(&mut self) -> Adc10fetchW<'_, Adc10dtc0Spec> {
                Adc10fetchW::new(self, 0)
            }
            #[doc = "Bit 1 - ADC10 block one"]
            #[inline(always)]
            pub fn adc10b1(&mut self) -> Adc10b1W<'_, Adc10dtc0Spec> {
                Adc10b1W::new(self, 1)
            }
            #[doc = "Bit 2 - ADC10 continuous transfer"]
            #[inline(always)]
            pub fn adc10ct(&mut self) -> Adc10ctW<'_, Adc10dtc0Spec> {
                Adc10ctW::new(self, 2)
            }
            #[doc = "Bit 3 - ADC10 two-block mode"]
            #[inline(always)]
            pub fn adc10tb(&mut self) -> Adc10tbW<'_, Adc10dtc0Spec> {
                Adc10tbW::new(self, 3)
            }
        }
        #[doc = "ADC10 Data Transfer Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10dtc0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10dtc0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10dtc0Spec;
        impl crate::RegisterSpec for Adc10dtc0Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`adc10dtc0::R`](R) reader structure"]
        impl crate::Readable for Adc10dtc0Spec {}
        #[doc = "`write(|w| ..)` method takes [`adc10dtc0::W`](W) writer structure"]
        impl crate::Writable for Adc10dtc0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADC10DTC0 to value 0"]
        impl crate::Resettable for Adc10dtc0Spec {}
    }
    #[doc = "ADC10DTC1 (rw) register accessor: ADC10 Data Transfer Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10dtc1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10dtc1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10dtc1`] module"]
    #[doc(alias = "ADC10DTC1")]
    pub type Adc10dtc1 = crate::Reg<adc10dtc1::Adc10dtc1Spec>;
    #[doc = "ADC10 Data Transfer Control 1"]
    pub mod adc10dtc1 {
        #[doc = "Register `ADC10DTC1` reader"]
        pub type R = crate::R<Adc10dtc1Spec>;
        #[doc = "Register `ADC10DTC1` writer"]
        pub type W = crate::W<Adc10dtc1Spec>;
        #[doc = "Field `ADC10DTC1` reader - ADC10 Data Transfer Control 1 Register"]
        pub type Adc10dtc1R = crate::FieldReader;
        #[doc = "Field `ADC10DTC1` writer - ADC10 Data Transfer Control 1 Register"]
        pub type Adc10dtc1W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - ADC10 Data Transfer Control 1 Register"]
            #[inline(always)]
            pub fn adc10dtc1(&self) -> Adc10dtc1R {
                Adc10dtc1R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - ADC10 Data Transfer Control 1 Register"]
            #[inline(always)]
            pub fn adc10dtc1(&mut self) -> Adc10dtc1W<'_, Adc10dtc1Spec> {
                Adc10dtc1W::new(self, 0)
            }
        }
        #[doc = "ADC10 Data Transfer Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10dtc1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10dtc1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10dtc1Spec;
        impl crate::RegisterSpec for Adc10dtc1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`adc10dtc1::R`](R) reader structure"]
        impl crate::Readable for Adc10dtc1Spec {}
        #[doc = "`write(|w| ..)` method takes [`adc10dtc1::W`](W) writer structure"]
        impl crate::Writable for Adc10dtc1Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets ADC10DTC1 to value 0"]
        impl crate::Resettable for Adc10dtc1Spec {}
    }
    #[doc = "ADC10AE0 (rw) register accessor: ADC10 Analog Enable 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ae0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ae0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10ae0`] module"]
    #[doc(alias = "ADC10AE0")]
    pub type Adc10ae0 = crate::Reg<adc10ae0::Adc10ae0Spec>;
    #[doc = "ADC10 Analog Enable 0"]
    pub mod adc10ae0 {
        #[doc = "Register `ADC10AE0` reader"]
        pub type R = crate::R<Adc10ae0Spec>;
        #[doc = "Register `ADC10AE0` writer"]
        pub type W = crate::W<Adc10ae0Spec>;
        #[doc = "Field `ADC10AE0` reader - ADC10 Input Enable 0 Register"]
        pub type Adc10ae0R = crate::FieldReader;
        #[doc = "Field `ADC10AE0` writer - ADC10 Input Enable 0 Register"]
        pub type Adc10ae0W<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - ADC10 Input Enable 0 Register"]
            #[inline(always)]
            pub fn adc10ae0(&self) -> Adc10ae0R {
                Adc10ae0R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - ADC10 Input Enable 0 Register"]
            #[inline(always)]
            pub fn adc10ae0(&mut self) -> Adc10ae0W<'_, Adc10ae0Spec> {
                Adc10ae0W::new(self, 0)
            }
        }
        #[doc = "ADC10 Analog Enable 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ae0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ae0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10ae0Spec;
        impl crate::RegisterSpec for Adc10ae0Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`adc10ae0::R`](R) reader structure"]
        impl crate::Readable for Adc10ae0Spec {}
        #[doc = "`write(|w| ..)` method takes [`adc10ae0::W`](W) writer structure"]
        impl crate::Writable for Adc10ae0Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets ADC10AE0 to value 0"]
        impl crate::Resettable for Adc10ae0Spec {}
    }
    #[doc = "ADC10CTL0 (rw) register accessor: ADC10 Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ctl0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ctl0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10ctl0`] module"]
    #[doc(alias = "ADC10CTL0")]
    pub type Adc10ctl0 = crate::Reg<adc10ctl0::Adc10ctl0Spec>;
    #[doc = "ADC10 Control 0"]
    pub mod adc10ctl0 {
        #[doc = "Register `ADC10CTL0` reader"]
        pub type R = crate::R<Adc10ctl0Spec>;
        #[doc = "Register `ADC10CTL0` writer"]
        pub type W = crate::W<Adc10ctl0Spec>;
        #[doc = "Field `ADC10SC` reader - ADC10 Start Conversion"]
        pub type Adc10scR = crate::BitReader;
        #[doc = "Field `ADC10SC` writer - ADC10 Start Conversion"]
        pub type Adc10scW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ENC` reader - ADC10 Enable Conversion"]
        pub type EncR = crate::BitReader;
        #[doc = "Field `ENC` writer - ADC10 Enable Conversion"]
        pub type EncW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10IFG` reader - ADC10 Interrupt Flag"]
        pub type Adc10ifgR = crate::BitReader;
        #[doc = "Field `ADC10IFG` writer - ADC10 Interrupt Flag"]
        pub type Adc10ifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10IE` reader - ADC10 Interrupt Enalbe"]
        pub type Adc10ieR = crate::BitReader;
        #[doc = "Field `ADC10IE` writer - ADC10 Interrupt Enalbe"]
        pub type Adc10ieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10ON` reader - ADC10 On/Enable"]
        pub type Adc10onR = crate::BitReader;
        #[doc = "Field `ADC10ON` writer - ADC10 On/Enable"]
        pub type Adc10onW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REFON` reader - ADC10 Reference on"]
        pub type RefonR = crate::BitReader;
        #[doc = "Field `REFON` writer - ADC10 Reference on"]
        pub type RefonW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REF2_5V` reader - ADC10 Ref 0:1.5V / 1:2.5V"]
        pub type Ref2_5vR = crate::BitReader;
        #[doc = "Field `REF2_5V` writer - ADC10 Ref 0:1.5V / 1:2.5V"]
        pub type Ref2_5vW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MSC` reader - ADC10 Multiple SampleConversion"]
        pub type MscR = crate::BitReader;
        #[doc = "Field `MSC` writer - ADC10 Multiple SampleConversion"]
        pub type MscW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REFBURST` reader - ADC10 Reference Burst Mode"]
        pub type RefburstR = crate::BitReader;
        #[doc = "Field `REFBURST` writer - ADC10 Reference Burst Mode"]
        pub type RefburstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REFOUT` reader - ADC10 Enalbe output of Ref."]
        pub type RefoutR = crate::BitReader;
        #[doc = "Field `REFOUT` writer - ADC10 Enalbe output of Ref."]
        pub type RefoutW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10SR` reader - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
        pub type Adc10srR = crate::BitReader;
        #[doc = "Field `ADC10SR` writer - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
        pub type Adc10srW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "ADC10 Sample Hold Select Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Adc10sht {
            #[doc = "0: 4 x ADC10CLKs"]
            Adc10sht0 = 0,
            #[doc = "1: 8 x ADC10CLKs"]
            Adc10sht1 = 1,
            #[doc = "2: 16 x ADC10CLKs"]
            Adc10sht2 = 2,
            #[doc = "3: 64 x ADC10CLKs"]
            Adc10sht3 = 3,
        }
        impl From<Adc10sht> for u8 {
            #[inline(always)]
            fn from(variant: Adc10sht) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Adc10sht {
            type Ux = u8;
        }
        impl crate::IsEnum for Adc10sht {}
        #[doc = "Field `ADC10SHT` reader - ADC10 Sample Hold Select Bit: 0"]
        pub type Adc10shtR = crate::FieldReader<Adc10sht>;
        impl Adc10shtR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Adc10sht {
                match self.bits {
                    0 => Adc10sht::Adc10sht0,
                    1 => Adc10sht::Adc10sht1,
                    2 => Adc10sht::Adc10sht2,
                    3 => Adc10sht::Adc10sht3,
                    _ => unreachable!(),
                }
            }
            #[doc = "4 x ADC10CLKs"]
            #[inline(always)]
            pub fn is_adc10sht_0(&self) -> bool {
                *self == Adc10sht::Adc10sht0
            }
            #[doc = "8 x ADC10CLKs"]
            #[inline(always)]
            pub fn is_adc10sht_1(&self) -> bool {
                *self == Adc10sht::Adc10sht1
            }
            #[doc = "16 x ADC10CLKs"]
            #[inline(always)]
            pub fn is_adc10sht_2(&self) -> bool {
                *self == Adc10sht::Adc10sht2
            }
            #[doc = "64 x ADC10CLKs"]
            #[inline(always)]
            pub fn is_adc10sht_3(&self) -> bool {
                *self == Adc10sht::Adc10sht3
            }
        }
        #[doc = "Field `ADC10SHT` writer - ADC10 Sample Hold Select Bit: 0"]
        pub type Adc10shtW<'a, REG> = crate::FieldWriter<'a, REG, 2, Adc10sht, crate::Safe>;
        impl<'a, REG> Adc10shtW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "4 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_0(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10sht::Adc10sht0)
            }
            #[doc = "8 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_1(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10sht::Adc10sht1)
            }
            #[doc = "16 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_2(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10sht::Adc10sht2)
            }
            #[doc = "64 x ADC10CLKs"]
            #[inline(always)]
            pub fn adc10sht_3(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10sht::Adc10sht3)
            }
        }
        #[doc = "ADC10 Reference Select Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Sref {
            #[doc = "0: VR+ = AVCC and VR- = AVSS"]
            Sref0 = 0,
            #[doc = "1: VR+ = VREF+ and VR- = AVSS"]
            Sref1 = 1,
            #[doc = "2: VR+ = VEREF+ and VR- = AVSS"]
            Sref2 = 2,
            #[doc = "3: VR+ = VEREF+ and VR- = AVSS"]
            Sref3 = 3,
            #[doc = "4: VR+ = AVCC and VR- = VREF-/VEREF-"]
            Sref4 = 4,
            #[doc = "5: VR+ = VREF+ and VR- = VREF-/VEREF-"]
            Sref5 = 5,
            #[doc = "6: VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            Sref6 = 6,
            #[doc = "7: VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            Sref7 = 7,
        }
        impl From<Sref> for u8 {
            #[inline(always)]
            fn from(variant: Sref) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Sref {
            type Ux = u8;
        }
        impl crate::IsEnum for Sref {}
        #[doc = "Field `SREF` reader - ADC10 Reference Select Bit: 0"]
        pub type SrefR = crate::FieldReader<Sref>;
        impl SrefR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Sref {
                match self.bits {
                    0 => Sref::Sref0,
                    1 => Sref::Sref1,
                    2 => Sref::Sref2,
                    3 => Sref::Sref3,
                    4 => Sref::Sref4,
                    5 => Sref::Sref5,
                    6 => Sref::Sref6,
                    7 => Sref::Sref7,
                    _ => unreachable!(),
                }
            }
            #[doc = "VR+ = AVCC and VR- = AVSS"]
            #[inline(always)]
            pub fn is_sref_0(&self) -> bool {
                *self == Sref::Sref0
            }
            #[doc = "VR+ = VREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn is_sref_1(&self) -> bool {
                *self == Sref::Sref1
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn is_sref_2(&self) -> bool {
                *self == Sref::Sref2
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn is_sref_3(&self) -> bool {
                *self == Sref::Sref3
            }
            #[doc = "VR+ = AVCC and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn is_sref_4(&self) -> bool {
                *self == Sref::Sref4
            }
            #[doc = "VR+ = VREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn is_sref_5(&self) -> bool {
                *self == Sref::Sref5
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn is_sref_6(&self) -> bool {
                *self == Sref::Sref6
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn is_sref_7(&self) -> bool {
                *self == Sref::Sref7
            }
        }
        #[doc = "Field `SREF` writer - ADC10 Reference Select Bit: 0"]
        pub type SrefW<'a, REG> = crate::FieldWriter<'a, REG, 3, Sref, crate::Safe>;
        impl<'a, REG> SrefW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "VR+ = AVCC and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_0(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref0)
            }
            #[doc = "VR+ = VREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_1(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref1)
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_2(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref2)
            }
            #[doc = "VR+ = VEREF+ and VR- = AVSS"]
            #[inline(always)]
            pub fn sref_3(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref3)
            }
            #[doc = "VR+ = AVCC and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_4(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref4)
            }
            #[doc = "VR+ = VREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_5(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref5)
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_6(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref6)
            }
            #[doc = "VR+ = VEREF+ and VR- = VREF-/VEREF-"]
            #[inline(always)]
            pub fn sref_7(self) -> &'a mut crate::W<REG> {
                self.variant(Sref::Sref7)
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC10 Start Conversion"]
            #[inline(always)]
            pub fn adc10sc(&self) -> Adc10scR {
                Adc10scR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - ADC10 Enable Conversion"]
            #[inline(always)]
            pub fn enc(&self) -> EncR {
                EncR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - ADC10 Interrupt Flag"]
            #[inline(always)]
            pub fn adc10ifg(&self) -> Adc10ifgR {
                Adc10ifgR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - ADC10 Interrupt Enalbe"]
            #[inline(always)]
            pub fn adc10ie(&self) -> Adc10ieR {
                Adc10ieR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - ADC10 On/Enable"]
            #[inline(always)]
            pub fn adc10on(&self) -> Adc10onR {
                Adc10onR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - ADC10 Reference on"]
            #[inline(always)]
            pub fn refon(&self) -> RefonR {
                RefonR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - ADC10 Ref 0:1.5V / 1:2.5V"]
            #[inline(always)]
            pub fn ref2_5v(&self) -> Ref2_5vR {
                Ref2_5vR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - ADC10 Multiple SampleConversion"]
            #[inline(always)]
            pub fn msc(&self) -> MscR {
                MscR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - ADC10 Reference Burst Mode"]
            #[inline(always)]
            pub fn refburst(&self) -> RefburstR {
                RefburstR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ADC10 Enalbe output of Ref."]
            #[inline(always)]
            pub fn refout(&self) -> RefoutR {
                RefoutR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
            #[inline(always)]
            pub fn adc10sr(&self) -> Adc10srR {
                Adc10srR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bits 11:12 - ADC10 Sample Hold Select Bit: 0"]
            #[inline(always)]
            pub fn adc10sht(&self) -> Adc10shtR {
                Adc10shtR::new(((self.bits >> 11) & 3) as u8)
            }
            #[doc = "Bits 13:15 - ADC10 Reference Select Bit: 0"]
            #[inline(always)]
            pub fn sref(&self) -> SrefR {
                SrefR::new(((self.bits >> 13) & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC10 Start Conversion"]
            #[inline(always)]
            pub fn adc10sc(&mut self) -> Adc10scW<'_, Adc10ctl0Spec> {
                Adc10scW::new(self, 0)
            }
            #[doc = "Bit 1 - ADC10 Enable Conversion"]
            #[inline(always)]
            pub fn enc(&mut self) -> EncW<'_, Adc10ctl0Spec> {
                EncW::new(self, 1)
            }
            #[doc = "Bit 2 - ADC10 Interrupt Flag"]
            #[inline(always)]
            pub fn adc10ifg(&mut self) -> Adc10ifgW<'_, Adc10ctl0Spec> {
                Adc10ifgW::new(self, 2)
            }
            #[doc = "Bit 3 - ADC10 Interrupt Enalbe"]
            #[inline(always)]
            pub fn adc10ie(&mut self) -> Adc10ieW<'_, Adc10ctl0Spec> {
                Adc10ieW::new(self, 3)
            }
            #[doc = "Bit 4 - ADC10 On/Enable"]
            #[inline(always)]
            pub fn adc10on(&mut self) -> Adc10onW<'_, Adc10ctl0Spec> {
                Adc10onW::new(self, 4)
            }
            #[doc = "Bit 5 - ADC10 Reference on"]
            #[inline(always)]
            pub fn refon(&mut self) -> RefonW<'_, Adc10ctl0Spec> {
                RefonW::new(self, 5)
            }
            #[doc = "Bit 6 - ADC10 Ref 0:1.5V / 1:2.5V"]
            #[inline(always)]
            pub fn ref2_5v(&mut self) -> Ref2_5vW<'_, Adc10ctl0Spec> {
                Ref2_5vW::new(self, 6)
            }
            #[doc = "Bit 7 - ADC10 Multiple SampleConversion"]
            #[inline(always)]
            pub fn msc(&mut self) -> MscW<'_, Adc10ctl0Spec> {
                MscW::new(self, 7)
            }
            #[doc = "Bit 8 - ADC10 Reference Burst Mode"]
            #[inline(always)]
            pub fn refburst(&mut self) -> RefburstW<'_, Adc10ctl0Spec> {
                RefburstW::new(self, 8)
            }
            #[doc = "Bit 9 - ADC10 Enalbe output of Ref."]
            #[inline(always)]
            pub fn refout(&mut self) -> RefoutW<'_, Adc10ctl0Spec> {
                RefoutW::new(self, 9)
            }
            #[doc = "Bit 10 - ADC10 Sampling Rate 0:200ksps / 1:50ksps"]
            #[inline(always)]
            pub fn adc10sr(&mut self) -> Adc10srW<'_, Adc10ctl0Spec> {
                Adc10srW::new(self, 10)
            }
            #[doc = "Bits 11:12 - ADC10 Sample Hold Select Bit: 0"]
            #[inline(always)]
            pub fn adc10sht(&mut self) -> Adc10shtW<'_, Adc10ctl0Spec> {
                Adc10shtW::new(self, 11)
            }
            #[doc = "Bits 13:15 - ADC10 Reference Select Bit: 0"]
            #[inline(always)]
            pub fn sref(&mut self) -> SrefW<'_, Adc10ctl0Spec> {
                SrefW::new(self, 13)
            }
        }
        #[doc = "ADC10 Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ctl0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ctl0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10ctl0Spec;
        impl crate::RegisterSpec for Adc10ctl0Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`adc10ctl0::R`](R) reader structure"]
        impl crate::Readable for Adc10ctl0Spec {}
        #[doc = "`write(|w| ..)` method takes [`adc10ctl0::W`](W) writer structure"]
        impl crate::Writable for Adc10ctl0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADC10CTL0 to value 0"]
        impl crate::Resettable for Adc10ctl0Spec {}
    }
    #[doc = "ADC10CTL1 (rw) register accessor: ADC10 Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10ctl1`] module"]
    #[doc(alias = "ADC10CTL1")]
    pub type Adc10ctl1 = crate::Reg<adc10ctl1::Adc10ctl1Spec>;
    #[doc = "ADC10 Control 1"]
    pub mod adc10ctl1 {
        #[doc = "Register `ADC10CTL1` reader"]
        pub type R = crate::R<Adc10ctl1Spec>;
        #[doc = "Register `ADC10CTL1` writer"]
        pub type W = crate::W<Adc10ctl1Spec>;
        #[doc = "Field `ADC10BUSY` reader - ADC10 BUSY"]
        pub type Adc10busyR = crate::BitReader;
        #[doc = "Field `ADC10BUSY` writer - ADC10 BUSY"]
        pub type Adc10busyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "ADC10 Conversion Sequence Select 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Conseq {
            #[doc = "0: Single channel single conversion"]
            Conseq0 = 0,
            #[doc = "1: Sequence of channels"]
            Conseq1 = 1,
            #[doc = "2: Repeat single channel"]
            Conseq2 = 2,
            #[doc = "3: Repeat sequence of channels"]
            Conseq3 = 3,
        }
        impl From<Conseq> for u8 {
            #[inline(always)]
            fn from(variant: Conseq) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Conseq {
            type Ux = u8;
        }
        impl crate::IsEnum for Conseq {}
        #[doc = "Field `CONSEQ` reader - ADC10 Conversion Sequence Select 0"]
        pub type ConseqR = crate::FieldReader<Conseq>;
        impl ConseqR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Conseq {
                match self.bits {
                    0 => Conseq::Conseq0,
                    1 => Conseq::Conseq1,
                    2 => Conseq::Conseq2,
                    3 => Conseq::Conseq3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Single channel single conversion"]
            #[inline(always)]
            pub fn is_conseq_0(&self) -> bool {
                *self == Conseq::Conseq0
            }
            #[doc = "Sequence of channels"]
            #[inline(always)]
            pub fn is_conseq_1(&self) -> bool {
                *self == Conseq::Conseq1
            }
            #[doc = "Repeat single channel"]
            #[inline(always)]
            pub fn is_conseq_2(&self) -> bool {
                *self == Conseq::Conseq2
            }
            #[doc = "Repeat sequence of channels"]
            #[inline(always)]
            pub fn is_conseq_3(&self) -> bool {
                *self == Conseq::Conseq3
            }
        }
        #[doc = "Field `CONSEQ` writer - ADC10 Conversion Sequence Select 0"]
        pub type ConseqW<'a, REG> = crate::FieldWriter<'a, REG, 2, Conseq, crate::Safe>;
        impl<'a, REG> ConseqW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Single channel single conversion"]
            #[inline(always)]
            pub fn conseq_0(self) -> &'a mut crate::W<REG> {
                self.variant(Conseq::Conseq0)
            }
            #[doc = "Sequence of channels"]
            #[inline(always)]
            pub fn conseq_1(self) -> &'a mut crate::W<REG> {
                self.variant(Conseq::Conseq1)
            }
            #[doc = "Repeat single channel"]
            #[inline(always)]
            pub fn conseq_2(self) -> &'a mut crate::W<REG> {
                self.variant(Conseq::Conseq2)
            }
            #[doc = "Repeat sequence of channels"]
            #[inline(always)]
            pub fn conseq_3(self) -> &'a mut crate::W<REG> {
                self.variant(Conseq::Conseq3)
            }
        }
        #[doc = "ADC10 Clock Source Select Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Adc10ssel {
            #[doc = "0: ADC10OSC"]
            Adc10ssel0 = 0,
            #[doc = "1: ACLK"]
            Adc10ssel1 = 1,
            #[doc = "2: MCLK"]
            Adc10ssel2 = 2,
            #[doc = "3: SMCLK"]
            Adc10ssel3 = 3,
        }
        impl From<Adc10ssel> for u8 {
            #[inline(always)]
            fn from(variant: Adc10ssel) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Adc10ssel {
            type Ux = u8;
        }
        impl crate::IsEnum for Adc10ssel {}
        #[doc = "Field `ADC10SSEL` reader - ADC10 Clock Source Select Bit: 0"]
        pub type Adc10sselR = crate::FieldReader<Adc10ssel>;
        impl Adc10sselR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Adc10ssel {
                match self.bits {
                    0 => Adc10ssel::Adc10ssel0,
                    1 => Adc10ssel::Adc10ssel1,
                    2 => Adc10ssel::Adc10ssel2,
                    3 => Adc10ssel::Adc10ssel3,
                    _ => unreachable!(),
                }
            }
            #[doc = "ADC10OSC"]
            #[inline(always)]
            pub fn is_adc10ssel_0(&self) -> bool {
                *self == Adc10ssel::Adc10ssel0
            }
            #[doc = "ACLK"]
            #[inline(always)]
            pub fn is_adc10ssel_1(&self) -> bool {
                *self == Adc10ssel::Adc10ssel1
            }
            #[doc = "MCLK"]
            #[inline(always)]
            pub fn is_adc10ssel_2(&self) -> bool {
                *self == Adc10ssel::Adc10ssel2
            }
            #[doc = "SMCLK"]
            #[inline(always)]
            pub fn is_adc10ssel_3(&self) -> bool {
                *self == Adc10ssel::Adc10ssel3
            }
        }
        #[doc = "Field `ADC10SSEL` writer - ADC10 Clock Source Select Bit: 0"]
        pub type Adc10sselW<'a, REG> = crate::FieldWriter<'a, REG, 2, Adc10ssel, crate::Safe>;
        impl<'a, REG> Adc10sselW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "ADC10OSC"]
            #[inline(always)]
            pub fn adc10ssel_0(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10ssel::Adc10ssel0)
            }
            #[doc = "ACLK"]
            #[inline(always)]
            pub fn adc10ssel_1(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10ssel::Adc10ssel1)
            }
            #[doc = "MCLK"]
            #[inline(always)]
            pub fn adc10ssel_2(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10ssel::Adc10ssel2)
            }
            #[doc = "SMCLK"]
            #[inline(always)]
            pub fn adc10ssel_3(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10ssel::Adc10ssel3)
            }
        }
        #[doc = "ADC10 Clock Divider Select Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Adc10div {
            #[doc = "0: ADC10 Clock Divider Select 0"]
            Adc10div0 = 0,
            #[doc = "1: ADC10 Clock Divider Select 1"]
            Adc10div1 = 1,
            #[doc = "2: ADC10 Clock Divider Select 2"]
            Adc10div2 = 2,
            #[doc = "3: ADC10 Clock Divider Select 3"]
            Adc10div3 = 3,
            #[doc = "4: ADC10 Clock Divider Select 4"]
            Adc10div4 = 4,
            #[doc = "5: ADC10 Clock Divider Select 5"]
            Adc10div5 = 5,
            #[doc = "6: ADC10 Clock Divider Select 6"]
            Adc10div6 = 6,
            #[doc = "7: ADC10 Clock Divider Select 7"]
            Adc10div7 = 7,
        }
        impl From<Adc10div> for u8 {
            #[inline(always)]
            fn from(variant: Adc10div) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Adc10div {
            type Ux = u8;
        }
        impl crate::IsEnum for Adc10div {}
        #[doc = "Field `ADC10DIV` reader - ADC10 Clock Divider Select Bit: 0"]
        pub type Adc10divR = crate::FieldReader<Adc10div>;
        impl Adc10divR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Adc10div {
                match self.bits {
                    0 => Adc10div::Adc10div0,
                    1 => Adc10div::Adc10div1,
                    2 => Adc10div::Adc10div2,
                    3 => Adc10div::Adc10div3,
                    4 => Adc10div::Adc10div4,
                    5 => Adc10div::Adc10div5,
                    6 => Adc10div::Adc10div6,
                    7 => Adc10div::Adc10div7,
                    _ => unreachable!(),
                }
            }
            #[doc = "ADC10 Clock Divider Select 0"]
            #[inline(always)]
            pub fn is_adc10div_0(&self) -> bool {
                *self == Adc10div::Adc10div0
            }
            #[doc = "ADC10 Clock Divider Select 1"]
            #[inline(always)]
            pub fn is_adc10div_1(&self) -> bool {
                *self == Adc10div::Adc10div1
            }
            #[doc = "ADC10 Clock Divider Select 2"]
            #[inline(always)]
            pub fn is_adc10div_2(&self) -> bool {
                *self == Adc10div::Adc10div2
            }
            #[doc = "ADC10 Clock Divider Select 3"]
            #[inline(always)]
            pub fn is_adc10div_3(&self) -> bool {
                *self == Adc10div::Adc10div3
            }
            #[doc = "ADC10 Clock Divider Select 4"]
            #[inline(always)]
            pub fn is_adc10div_4(&self) -> bool {
                *self == Adc10div::Adc10div4
            }
            #[doc = "ADC10 Clock Divider Select 5"]
            #[inline(always)]
            pub fn is_adc10div_5(&self) -> bool {
                *self == Adc10div::Adc10div5
            }
            #[doc = "ADC10 Clock Divider Select 6"]
            #[inline(always)]
            pub fn is_adc10div_6(&self) -> bool {
                *self == Adc10div::Adc10div6
            }
            #[doc = "ADC10 Clock Divider Select 7"]
            #[inline(always)]
            pub fn is_adc10div_7(&self) -> bool {
                *self == Adc10div::Adc10div7
            }
        }
        #[doc = "Field `ADC10DIV` writer - ADC10 Clock Divider Select Bit: 0"]
        pub type Adc10divW<'a, REG> = crate::FieldWriter<'a, REG, 3, Adc10div, crate::Safe>;
        impl<'a, REG> Adc10divW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "ADC10 Clock Divider Select 0"]
            #[inline(always)]
            pub fn adc10div_0(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div0)
            }
            #[doc = "ADC10 Clock Divider Select 1"]
            #[inline(always)]
            pub fn adc10div_1(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div1)
            }
            #[doc = "ADC10 Clock Divider Select 2"]
            #[inline(always)]
            pub fn adc10div_2(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div2)
            }
            #[doc = "ADC10 Clock Divider Select 3"]
            #[inline(always)]
            pub fn adc10div_3(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div3)
            }
            #[doc = "ADC10 Clock Divider Select 4"]
            #[inline(always)]
            pub fn adc10div_4(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div4)
            }
            #[doc = "ADC10 Clock Divider Select 5"]
            #[inline(always)]
            pub fn adc10div_5(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div5)
            }
            #[doc = "ADC10 Clock Divider Select 6"]
            #[inline(always)]
            pub fn adc10div_6(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div6)
            }
            #[doc = "ADC10 Clock Divider Select 7"]
            #[inline(always)]
            pub fn adc10div_7(self) -> &'a mut crate::W<REG> {
                self.variant(Adc10div::Adc10div7)
            }
        }
        #[doc = "Field `ISSH` reader - ADC10 Invert Sample Hold Signal"]
        pub type IsshR = crate::BitReader;
        #[doc = "Field `ISSH` writer - ADC10 Invert Sample Hold Signal"]
        pub type IsshW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADC10DF` reader - ADC10 Data Format 0:binary 1:2's complement"]
        pub type Adc10dfR = crate::BitReader;
        #[doc = "Field `ADC10DF` writer - ADC10 Data Format 0:binary 1:2's complement"]
        pub type Adc10dfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "ADC10 Sample/Hold Source Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Shs {
            #[doc = "0: ADC10SC"]
            Shs0 = 0,
            #[doc = "1: TA3 OUT1"]
            Shs1 = 1,
            #[doc = "2: TA3 OUT0"]
            Shs2 = 2,
            #[doc = "3: TA3 OUT2"]
            Shs3 = 3,
        }
        impl From<Shs> for u8 {
            #[inline(always)]
            fn from(variant: Shs) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Shs {
            type Ux = u8;
        }
        impl crate::IsEnum for Shs {}
        #[doc = "Field `SHS` reader - ADC10 Sample/Hold Source Bit: 0"]
        pub type ShsR = crate::FieldReader<Shs>;
        impl ShsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Shs {
                match self.bits {
                    0 => Shs::Shs0,
                    1 => Shs::Shs1,
                    2 => Shs::Shs2,
                    3 => Shs::Shs3,
                    _ => unreachable!(),
                }
            }
            #[doc = "ADC10SC"]
            #[inline(always)]
            pub fn is_shs_0(&self) -> bool {
                *self == Shs::Shs0
            }
            #[doc = "TA3 OUT1"]
            #[inline(always)]
            pub fn is_shs_1(&self) -> bool {
                *self == Shs::Shs1
            }
            #[doc = "TA3 OUT0"]
            #[inline(always)]
            pub fn is_shs_2(&self) -> bool {
                *self == Shs::Shs2
            }
            #[doc = "TA3 OUT2"]
            #[inline(always)]
            pub fn is_shs_3(&self) -> bool {
                *self == Shs::Shs3
            }
        }
        #[doc = "Field `SHS` writer - ADC10 Sample/Hold Source Bit: 0"]
        pub type ShsW<'a, REG> = crate::FieldWriter<'a, REG, 2, Shs, crate::Safe>;
        impl<'a, REG> ShsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "ADC10SC"]
            #[inline(always)]
            pub fn shs_0(self) -> &'a mut crate::W<REG> {
                self.variant(Shs::Shs0)
            }
            #[doc = "TA3 OUT1"]
            #[inline(always)]
            pub fn shs_1(self) -> &'a mut crate::W<REG> {
                self.variant(Shs::Shs1)
            }
            #[doc = "TA3 OUT0"]
            #[inline(always)]
            pub fn shs_2(self) -> &'a mut crate::W<REG> {
                self.variant(Shs::Shs2)
            }
            #[doc = "TA3 OUT2"]
            #[inline(always)]
            pub fn shs_3(self) -> &'a mut crate::W<REG> {
                self.variant(Shs::Shs3)
            }
        }
        #[doc = "ADC10 Input Channel Select Bit: 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Inch {
            #[doc = "0: Selects Channel 0"]
            Inch0 = 0,
            #[doc = "1: Selects Channel 1"]
            Inch1 = 1,
            #[doc = "2: Selects Channel 2"]
            Inch2 = 2,
            #[doc = "3: Selects Channel 3"]
            Inch3 = 3,
            #[doc = "4: Selects Channel 4"]
            Inch4 = 4,
            #[doc = "5: Selects Channel 5"]
            Inch5 = 5,
            #[doc = "6: Selects Channel 6"]
            Inch6 = 6,
            #[doc = "7: Selects Channel 7"]
            Inch7 = 7,
            #[doc = "8: Selects Channel 8"]
            Inch8 = 8,
            #[doc = "9: Selects Channel 9"]
            Inch9 = 9,
            #[doc = "10: Selects Channel 10"]
            Inch10 = 10,
            #[doc = "11: Selects Channel 11"]
            Inch11 = 11,
            #[doc = "12: Selects Channel 12"]
            Inch12 = 12,
            #[doc = "13: Selects Channel 13"]
            Inch13 = 13,
            #[doc = "14: Selects Channel 14"]
            Inch14 = 14,
            #[doc = "15: Selects Channel 15"]
            Inch15 = 15,
        }
        impl From<Inch> for u8 {
            #[inline(always)]
            fn from(variant: Inch) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Inch {
            type Ux = u8;
        }
        impl crate::IsEnum for Inch {}
        #[doc = "Field `INCH` reader - ADC10 Input Channel Select Bit: 0"]
        pub type InchR = crate::FieldReader<Inch>;
        impl InchR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Inch {
                match self.bits {
                    0 => Inch::Inch0,
                    1 => Inch::Inch1,
                    2 => Inch::Inch2,
                    3 => Inch::Inch3,
                    4 => Inch::Inch4,
                    5 => Inch::Inch5,
                    6 => Inch::Inch6,
                    7 => Inch::Inch7,
                    8 => Inch::Inch8,
                    9 => Inch::Inch9,
                    10 => Inch::Inch10,
                    11 => Inch::Inch11,
                    12 => Inch::Inch12,
                    13 => Inch::Inch13,
                    14 => Inch::Inch14,
                    15 => Inch::Inch15,
                    _ => unreachable!(),
                }
            }
            #[doc = "Selects Channel 0"]
            #[inline(always)]
            pub fn is_inch_0(&self) -> bool {
                *self == Inch::Inch0
            }
            #[doc = "Selects Channel 1"]
            #[inline(always)]
            pub fn is_inch_1(&self) -> bool {
                *self == Inch::Inch1
            }
            #[doc = "Selects Channel 2"]
            #[inline(always)]
            pub fn is_inch_2(&self) -> bool {
                *self == Inch::Inch2
            }
            #[doc = "Selects Channel 3"]
            #[inline(always)]
            pub fn is_inch_3(&self) -> bool {
                *self == Inch::Inch3
            }
            #[doc = "Selects Channel 4"]
            #[inline(always)]
            pub fn is_inch_4(&self) -> bool {
                *self == Inch::Inch4
            }
            #[doc = "Selects Channel 5"]
            #[inline(always)]
            pub fn is_inch_5(&self) -> bool {
                *self == Inch::Inch5
            }
            #[doc = "Selects Channel 6"]
            #[inline(always)]
            pub fn is_inch_6(&self) -> bool {
                *self == Inch::Inch6
            }
            #[doc = "Selects Channel 7"]
            #[inline(always)]
            pub fn is_inch_7(&self) -> bool {
                *self == Inch::Inch7
            }
            #[doc = "Selects Channel 8"]
            #[inline(always)]
            pub fn is_inch_8(&self) -> bool {
                *self == Inch::Inch8
            }
            #[doc = "Selects Channel 9"]
            #[inline(always)]
            pub fn is_inch_9(&self) -> bool {
                *self == Inch::Inch9
            }
            #[doc = "Selects Channel 10"]
            #[inline(always)]
            pub fn is_inch_10(&self) -> bool {
                *self == Inch::Inch10
            }
            #[doc = "Selects Channel 11"]
            #[inline(always)]
            pub fn is_inch_11(&self) -> bool {
                *self == Inch::Inch11
            }
            #[doc = "Selects Channel 12"]
            #[inline(always)]
            pub fn is_inch_12(&self) -> bool {
                *self == Inch::Inch12
            }
            #[doc = "Selects Channel 13"]
            #[inline(always)]
            pub fn is_inch_13(&self) -> bool {
                *self == Inch::Inch13
            }
            #[doc = "Selects Channel 14"]
            #[inline(always)]
            pub fn is_inch_14(&self) -> bool {
                *self == Inch::Inch14
            }
            #[doc = "Selects Channel 15"]
            #[inline(always)]
            pub fn is_inch_15(&self) -> bool {
                *self == Inch::Inch15
            }
        }
        #[doc = "Field `INCH` writer - ADC10 Input Channel Select Bit: 0"]
        pub type InchW<'a, REG> = crate::FieldWriter<'a, REG, 4, Inch, crate::Safe>;
        impl<'a, REG> InchW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Selects Channel 0"]
            #[inline(always)]
            pub fn inch_0(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch0)
            }
            #[doc = "Selects Channel 1"]
            #[inline(always)]
            pub fn inch_1(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch1)
            }
            #[doc = "Selects Channel 2"]
            #[inline(always)]
            pub fn inch_2(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch2)
            }
            #[doc = "Selects Channel 3"]
            #[inline(always)]
            pub fn inch_3(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch3)
            }
            #[doc = "Selects Channel 4"]
            #[inline(always)]
            pub fn inch_4(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch4)
            }
            #[doc = "Selects Channel 5"]
            #[inline(always)]
            pub fn inch_5(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch5)
            }
            #[doc = "Selects Channel 6"]
            #[inline(always)]
            pub fn inch_6(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch6)
            }
            #[doc = "Selects Channel 7"]
            #[inline(always)]
            pub fn inch_7(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch7)
            }
            #[doc = "Selects Channel 8"]
            #[inline(always)]
            pub fn inch_8(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch8)
            }
            #[doc = "Selects Channel 9"]
            #[inline(always)]
            pub fn inch_9(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch9)
            }
            #[doc = "Selects Channel 10"]
            #[inline(always)]
            pub fn inch_10(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch10)
            }
            #[doc = "Selects Channel 11"]
            #[inline(always)]
            pub fn inch_11(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch11)
            }
            #[doc = "Selects Channel 12"]
            #[inline(always)]
            pub fn inch_12(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch12)
            }
            #[doc = "Selects Channel 13"]
            #[inline(always)]
            pub fn inch_13(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch13)
            }
            #[doc = "Selects Channel 14"]
            #[inline(always)]
            pub fn inch_14(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch14)
            }
            #[doc = "Selects Channel 15"]
            #[inline(always)]
            pub fn inch_15(self) -> &'a mut crate::W<REG> {
                self.variant(Inch::Inch15)
            }
        }
        impl R {
            #[doc = "Bit 0 - ADC10 BUSY"]
            #[inline(always)]
            pub fn adc10busy(&self) -> Adc10busyR {
                Adc10busyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:2 - ADC10 Conversion Sequence Select 0"]
            #[inline(always)]
            pub fn conseq(&self) -> ConseqR {
                ConseqR::new(((self.bits >> 1) & 3) as u8)
            }
            #[doc = "Bits 3:4 - ADC10 Clock Source Select Bit: 0"]
            #[inline(always)]
            pub fn adc10ssel(&self) -> Adc10sselR {
                Adc10sselR::new(((self.bits >> 3) & 3) as u8)
            }
            #[doc = "Bits 5:7 - ADC10 Clock Divider Select Bit: 0"]
            #[inline(always)]
            pub fn adc10div(&self) -> Adc10divR {
                Adc10divR::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bit 8 - ADC10 Invert Sample Hold Signal"]
            #[inline(always)]
            pub fn issh(&self) -> IsshR {
                IsshR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - ADC10 Data Format 0:binary 1:2's complement"]
            #[inline(always)]
            pub fn adc10df(&self) -> Adc10dfR {
                Adc10dfR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:11 - ADC10 Sample/Hold Source Bit: 0"]
            #[inline(always)]
            pub fn shs(&self) -> ShsR {
                ShsR::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bits 12:15 - ADC10 Input Channel Select Bit: 0"]
            #[inline(always)]
            pub fn inch(&self) -> InchR {
                InchR::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - ADC10 BUSY"]
            #[inline(always)]
            pub fn adc10busy(&mut self) -> Adc10busyW<'_, Adc10ctl1Spec> {
                Adc10busyW::new(self, 0)
            }
            #[doc = "Bits 1:2 - ADC10 Conversion Sequence Select 0"]
            #[inline(always)]
            pub fn conseq(&mut self) -> ConseqW<'_, Adc10ctl1Spec> {
                ConseqW::new(self, 1)
            }
            #[doc = "Bits 3:4 - ADC10 Clock Source Select Bit: 0"]
            #[inline(always)]
            pub fn adc10ssel(&mut self) -> Adc10sselW<'_, Adc10ctl1Spec> {
                Adc10sselW::new(self, 3)
            }
            #[doc = "Bits 5:7 - ADC10 Clock Divider Select Bit: 0"]
            #[inline(always)]
            pub fn adc10div(&mut self) -> Adc10divW<'_, Adc10ctl1Spec> {
                Adc10divW::new(self, 5)
            }
            #[doc = "Bit 8 - ADC10 Invert Sample Hold Signal"]
            #[inline(always)]
            pub fn issh(&mut self) -> IsshW<'_, Adc10ctl1Spec> {
                IsshW::new(self, 8)
            }
            #[doc = "Bit 9 - ADC10 Data Format 0:binary 1:2's complement"]
            #[inline(always)]
            pub fn adc10df(&mut self) -> Adc10dfW<'_, Adc10ctl1Spec> {
                Adc10dfW::new(self, 9)
            }
            #[doc = "Bits 10:11 - ADC10 Sample/Hold Source Bit: 0"]
            #[inline(always)]
            pub fn shs(&mut self) -> ShsW<'_, Adc10ctl1Spec> {
                ShsW::new(self, 10)
            }
            #[doc = "Bits 12:15 - ADC10 Input Channel Select Bit: 0"]
            #[inline(always)]
            pub fn inch(&mut self) -> InchW<'_, Adc10ctl1Spec> {
                InchW::new(self, 12)
            }
        }
        #[doc = "ADC10 Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10ctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10ctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10ctl1Spec;
        impl crate::RegisterSpec for Adc10ctl1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`adc10ctl1::R`](R) reader structure"]
        impl crate::Readable for Adc10ctl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`adc10ctl1::W`](W) writer structure"]
        impl crate::Writable for Adc10ctl1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADC10CTL1 to value 0"]
        impl crate::Resettable for Adc10ctl1Spec {}
    }
    #[doc = "ADC10MEM (rw) register accessor: ADC10 Memory\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10mem::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10mem::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10mem`] module"]
    #[doc(alias = "ADC10MEM")]
    pub type Adc10mem = crate::Reg<adc10mem::Adc10memSpec>;
    #[doc = "ADC10 Memory"]
    pub mod adc10mem {
        #[doc = "Register `ADC10MEM` reader"]
        pub type R = crate::R<Adc10memSpec>;
        #[doc = "Register `ADC10MEM` writer"]
        pub type W = crate::W<Adc10memSpec>;
        #[doc = "Field `ADC10MEM` reader - ADC10 Memory Register"]
        pub type Adc10memR = crate::FieldReader<u16>;
        #[doc = "Field `ADC10MEM` writer - ADC10 Memory Register"]
        pub type Adc10memW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - ADC10 Memory Register"]
            #[inline(always)]
            pub fn adc10mem(&self) -> Adc10memR {
                Adc10memR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC10 Memory Register"]
            #[inline(always)]
            pub fn adc10mem(&mut self) -> Adc10memW<'_, Adc10memSpec> {
                Adc10memW::new(self, 0)
            }
        }
        #[doc = "ADC10 Memory\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10mem::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10mem::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10memSpec;
        impl crate::RegisterSpec for Adc10memSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`adc10mem::R`](R) reader structure"]
        impl crate::Readable for Adc10memSpec {}
        #[doc = "`write(|w| ..)` method takes [`adc10mem::W`](W) writer structure"]
        impl crate::Writable for Adc10memSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets ADC10MEM to value 0"]
        impl crate::Resettable for Adc10memSpec {}
    }
    #[doc = "ADC10SA (rw) register accessor: ADC10 Data Transfer Start Address\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10sa::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10sa::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc10sa`] module"]
    #[doc(alias = "ADC10SA")]
    pub type Adc10sa = crate::Reg<adc10sa::Adc10saSpec>;
    #[doc = "ADC10 Data Transfer Start Address"]
    pub mod adc10sa {
        #[doc = "Register `ADC10SA` reader"]
        pub type R = crate::R<Adc10saSpec>;
        #[doc = "Register `ADC10SA` writer"]
        pub type W = crate::W<Adc10saSpec>;
        #[doc = "Field `ADC10SA` reader - ADC10 Data Transfer Start Address Register"]
        pub type Adc10saR = crate::FieldReader<u16>;
        #[doc = "Field `ADC10SA` writer - ADC10 Data Transfer Start Address Register"]
        pub type Adc10saW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - ADC10 Data Transfer Start Address Register"]
            #[inline(always)]
            pub fn adc10sa(&self) -> Adc10saR {
                Adc10saR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - ADC10 Data Transfer Start Address Register"]
            #[inline(always)]
            pub fn adc10sa(&mut self) -> Adc10saW<'_, Adc10saSpec> {
                Adc10saW::new(self, 0)
            }
        }
        #[doc = "ADC10 Data Transfer Start Address\n\nYou can [`read`](crate::Reg::read) this register and get [`adc10sa::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc10sa::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Adc10saSpec;
        impl crate::RegisterSpec for Adc10saSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`adc10sa::R`](R) reader structure"]
        impl crate::Readable for Adc10saSpec {}
        #[doc = "`write(|w| ..)` method takes [`adc10sa::W`](W) writer structure"]
        impl crate::Writable for Adc10saSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets ADC10SA to value 0"]
        impl crate::Resettable for Adc10saSpec {}
    }
}
#[doc = "System Clock"]
pub type SystemClock = crate::Periph<system_clock::RegisterBlock, 0x52>;
impl core::fmt::Debug for SystemClock {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SystemClock").finish()
    }
}
#[doc = "System Clock"]
pub mod system_clock {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x01],
        bcsctl3: Bcsctl3,
        _reserved1: [u8; 0x02],
        dcoctl: Dcoctl,
        bcsctl1: Bcsctl1,
        bcsctl2: Bcsctl2,
    }
    impl RegisterBlock {
        #[doc = "0x01 - Basic Clock System Control 3"]
        #[inline(always)]
        pub const fn bcsctl3(&self) -> &Bcsctl3 {
            &self.bcsctl3
        }
        #[doc = "0x04 - DCO Clock Frequency Control"]
        #[inline(always)]
        pub const fn dcoctl(&self) -> &Dcoctl {
            &self.dcoctl
        }
        #[doc = "0x05 - Basic Clock System Control 1"]
        #[inline(always)]
        pub const fn bcsctl1(&self) -> &Bcsctl1 {
            &self.bcsctl1
        }
        #[doc = "0x06 - Basic Clock System Control 2"]
        #[inline(always)]
        pub const fn bcsctl2(&self) -> &Bcsctl2 {
            &self.bcsctl2
        }
    }
    #[doc = "BCSCTL3 (rw) register accessor: Basic Clock System Control 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcsctl3`] module"]
    #[doc(alias = "BCSCTL3")]
    pub type Bcsctl3 = crate::Reg<bcsctl3::Bcsctl3Spec>;
    #[doc = "Basic Clock System Control 3"]
    pub mod bcsctl3 {
        #[doc = "Register `BCSCTL3` reader"]
        pub type R = crate::R<Bcsctl3Spec>;
        #[doc = "Register `BCSCTL3` writer"]
        pub type W = crate::W<Bcsctl3Spec>;
        #[doc = "Field `LFXT1OF` reader - Low/high Frequency Oscillator Fault Flag"]
        pub type Lfxt1ofR = crate::BitReader;
        #[doc = "Field `LFXT1OF` writer - Low/high Frequency Oscillator Fault Flag"]
        pub type Lfxt1ofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `XT2OF` reader - High frequency oscillator 2 fault flag"]
        pub type Xt2ofR = crate::BitReader;
        #[doc = "Field `XT2OF` writer - High frequency oscillator 2 fault flag"]
        pub type Xt2ofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "XIN/XOUT Cap 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Xcap {
            #[doc = "0: XIN/XOUT Cap : 0 pF"]
            Xcap0 = 0,
            #[doc = "1: XIN/XOUT Cap : 6 pF"]
            Xcap1 = 1,
            #[doc = "2: XIN/XOUT Cap : 10 pF"]
            Xcap2 = 2,
            #[doc = "3: XIN/XOUT Cap : 12.5 pF"]
            Xcap3 = 3,
        }
        impl From<Xcap> for u8 {
            #[inline(always)]
            fn from(variant: Xcap) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Xcap {
            type Ux = u8;
        }
        impl crate::IsEnum for Xcap {}
        #[doc = "Field `XCAP` reader - XIN/XOUT Cap 0"]
        pub type XcapR = crate::FieldReader<Xcap>;
        impl XcapR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Xcap {
                match self.bits {
                    0 => Xcap::Xcap0,
                    1 => Xcap::Xcap1,
                    2 => Xcap::Xcap2,
                    3 => Xcap::Xcap3,
                    _ => unreachable!(),
                }
            }
            #[doc = "XIN/XOUT Cap : 0 pF"]
            #[inline(always)]
            pub fn is_xcap_0(&self) -> bool {
                *self == Xcap::Xcap0
            }
            #[doc = "XIN/XOUT Cap : 6 pF"]
            #[inline(always)]
            pub fn is_xcap_1(&self) -> bool {
                *self == Xcap::Xcap1
            }
            #[doc = "XIN/XOUT Cap : 10 pF"]
            #[inline(always)]
            pub fn is_xcap_2(&self) -> bool {
                *self == Xcap::Xcap2
            }
            #[doc = "XIN/XOUT Cap : 12.5 pF"]
            #[inline(always)]
            pub fn is_xcap_3(&self) -> bool {
                *self == Xcap::Xcap3
            }
        }
        #[doc = "Field `XCAP` writer - XIN/XOUT Cap 0"]
        pub type XcapW<'a, REG> = crate::FieldWriter<'a, REG, 2, Xcap, crate::Safe>;
        impl<'a, REG> XcapW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "XIN/XOUT Cap : 0 pF"]
            #[inline(always)]
            pub fn xcap_0(self) -> &'a mut crate::W<REG> {
                self.variant(Xcap::Xcap0)
            }
            #[doc = "XIN/XOUT Cap : 6 pF"]
            #[inline(always)]
            pub fn xcap_1(self) -> &'a mut crate::W<REG> {
                self.variant(Xcap::Xcap1)
            }
            #[doc = "XIN/XOUT Cap : 10 pF"]
            #[inline(always)]
            pub fn xcap_2(self) -> &'a mut crate::W<REG> {
                self.variant(Xcap::Xcap2)
            }
            #[doc = "XIN/XOUT Cap : 12.5 pF"]
            #[inline(always)]
            pub fn xcap_3(self) -> &'a mut crate::W<REG> {
                self.variant(Xcap::Xcap3)
            }
        }
        #[doc = "Mode 0 for LFXT1 (XTS = 0)\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Lfxt1s {
            #[doc = "0: Mode 0 for LFXT1 : Normal operation"]
            Lfxt1s0 = 0,
            #[doc = "1: Mode 1 for LFXT1 : Reserved"]
            Lfxt1s1 = 1,
            #[doc = "2: Mode 2 for LFXT1 : VLO"]
            Lfxt1s2 = 2,
            #[doc = "3: Mode 3 for LFXT1 : Digital input signal"]
            Lfxt1s3 = 3,
        }
        impl From<Lfxt1s> for u8 {
            #[inline(always)]
            fn from(variant: Lfxt1s) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Lfxt1s {
            type Ux = u8;
        }
        impl crate::IsEnum for Lfxt1s {}
        #[doc = "Field `LFXT1S` reader - Mode 0 for LFXT1 (XTS = 0)"]
        pub type Lfxt1sR = crate::FieldReader<Lfxt1s>;
        impl Lfxt1sR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Lfxt1s {
                match self.bits {
                    0 => Lfxt1s::Lfxt1s0,
                    1 => Lfxt1s::Lfxt1s1,
                    2 => Lfxt1s::Lfxt1s2,
                    3 => Lfxt1s::Lfxt1s3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Mode 0 for LFXT1 : Normal operation"]
            #[inline(always)]
            pub fn is_lfxt1s_0(&self) -> bool {
                *self == Lfxt1s::Lfxt1s0
            }
            #[doc = "Mode 1 for LFXT1 : Reserved"]
            #[inline(always)]
            pub fn is_lfxt1s_1(&self) -> bool {
                *self == Lfxt1s::Lfxt1s1
            }
            #[doc = "Mode 2 for LFXT1 : VLO"]
            #[inline(always)]
            pub fn is_lfxt1s_2(&self) -> bool {
                *self == Lfxt1s::Lfxt1s2
            }
            #[doc = "Mode 3 for LFXT1 : Digital input signal"]
            #[inline(always)]
            pub fn is_lfxt1s_3(&self) -> bool {
                *self == Lfxt1s::Lfxt1s3
            }
        }
        #[doc = "Field `LFXT1S` writer - Mode 0 for LFXT1 (XTS = 0)"]
        pub type Lfxt1sW<'a, REG> = crate::FieldWriter<'a, REG, 2, Lfxt1s, crate::Safe>;
        impl<'a, REG> Lfxt1sW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Mode 0 for LFXT1 : Normal operation"]
            #[inline(always)]
            pub fn lfxt1s_0(self) -> &'a mut crate::W<REG> {
                self.variant(Lfxt1s::Lfxt1s0)
            }
            #[doc = "Mode 1 for LFXT1 : Reserved"]
            #[inline(always)]
            pub fn lfxt1s_1(self) -> &'a mut crate::W<REG> {
                self.variant(Lfxt1s::Lfxt1s1)
            }
            #[doc = "Mode 2 for LFXT1 : VLO"]
            #[inline(always)]
            pub fn lfxt1s_2(self) -> &'a mut crate::W<REG> {
                self.variant(Lfxt1s::Lfxt1s2)
            }
            #[doc = "Mode 3 for LFXT1 : Digital input signal"]
            #[inline(always)]
            pub fn lfxt1s_3(self) -> &'a mut crate::W<REG> {
                self.variant(Lfxt1s::Lfxt1s3)
            }
        }
        #[doc = "Mode 0 for XT2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Xt2s {
            #[doc = "0: Mode 0 for XT2 : 0.4 - 1 MHz"]
            Xt2s0 = 0,
            #[doc = "1: Mode 1 for XT2 : 1 - 4 MHz"]
            Xt2s1 = 1,
            #[doc = "2: Mode 2 for XT2 : 2 - 16 MHz"]
            Xt2s2 = 2,
            #[doc = "3: Mode 3 for XT2 : Digital input signal"]
            Xt2s3 = 3,
        }
        impl From<Xt2s> for u8 {
            #[inline(always)]
            fn from(variant: Xt2s) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Xt2s {
            type Ux = u8;
        }
        impl crate::IsEnum for Xt2s {}
        #[doc = "Field `XT2S` reader - Mode 0 for XT2"]
        pub type Xt2sR = crate::FieldReader<Xt2s>;
        impl Xt2sR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Xt2s {
                match self.bits {
                    0 => Xt2s::Xt2s0,
                    1 => Xt2s::Xt2s1,
                    2 => Xt2s::Xt2s2,
                    3 => Xt2s::Xt2s3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Mode 0 for XT2 : 0.4 - 1 MHz"]
            #[inline(always)]
            pub fn is_xt2s_0(&self) -> bool {
                *self == Xt2s::Xt2s0
            }
            #[doc = "Mode 1 for XT2 : 1 - 4 MHz"]
            #[inline(always)]
            pub fn is_xt2s_1(&self) -> bool {
                *self == Xt2s::Xt2s1
            }
            #[doc = "Mode 2 for XT2 : 2 - 16 MHz"]
            #[inline(always)]
            pub fn is_xt2s_2(&self) -> bool {
                *self == Xt2s::Xt2s2
            }
            #[doc = "Mode 3 for XT2 : Digital input signal"]
            #[inline(always)]
            pub fn is_xt2s_3(&self) -> bool {
                *self == Xt2s::Xt2s3
            }
        }
        #[doc = "Field `XT2S` writer - Mode 0 for XT2"]
        pub type Xt2sW<'a, REG> = crate::FieldWriter<'a, REG, 2, Xt2s, crate::Safe>;
        impl<'a, REG> Xt2sW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Mode 0 for XT2 : 0.4 - 1 MHz"]
            #[inline(always)]
            pub fn xt2s_0(self) -> &'a mut crate::W<REG> {
                self.variant(Xt2s::Xt2s0)
            }
            #[doc = "Mode 1 for XT2 : 1 - 4 MHz"]
            #[inline(always)]
            pub fn xt2s_1(self) -> &'a mut crate::W<REG> {
                self.variant(Xt2s::Xt2s1)
            }
            #[doc = "Mode 2 for XT2 : 2 - 16 MHz"]
            #[inline(always)]
            pub fn xt2s_2(self) -> &'a mut crate::W<REG> {
                self.variant(Xt2s::Xt2s2)
            }
            #[doc = "Mode 3 for XT2 : Digital input signal"]
            #[inline(always)]
            pub fn xt2s_3(self) -> &'a mut crate::W<REG> {
                self.variant(Xt2s::Xt2s3)
            }
        }
        impl R {
            #[doc = "Bit 0 - Low/high Frequency Oscillator Fault Flag"]
            #[inline(always)]
            pub fn lfxt1of(&self) -> Lfxt1ofR {
                Lfxt1ofR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - High frequency oscillator 2 fault flag"]
            #[inline(always)]
            pub fn xt2of(&self) -> Xt2ofR {
                Xt2ofR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - XIN/XOUT Cap 0"]
            #[inline(always)]
            pub fn xcap(&self) -> XcapR {
                XcapR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bits 4:5 - Mode 0 for LFXT1 (XTS = 0)"]
            #[inline(always)]
            pub fn lfxt1s(&self) -> Lfxt1sR {
                Lfxt1sR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bits 6:7 - Mode 0 for XT2"]
            #[inline(always)]
            pub fn xt2s(&self) -> Xt2sR {
                Xt2sR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - Low/high Frequency Oscillator Fault Flag"]
            #[inline(always)]
            pub fn lfxt1of(&mut self) -> Lfxt1ofW<'_, Bcsctl3Spec> {
                Lfxt1ofW::new(self, 0)
            }
            #[doc = "Bit 1 - High frequency oscillator 2 fault flag"]
            #[inline(always)]
            pub fn xt2of(&mut self) -> Xt2ofW<'_, Bcsctl3Spec> {
                Xt2ofW::new(self, 1)
            }
            #[doc = "Bits 2:3 - XIN/XOUT Cap 0"]
            #[inline(always)]
            pub fn xcap(&mut self) -> XcapW<'_, Bcsctl3Spec> {
                XcapW::new(self, 2)
            }
            #[doc = "Bits 4:5 - Mode 0 for LFXT1 (XTS = 0)"]
            #[inline(always)]
            pub fn lfxt1s(&mut self) -> Lfxt1sW<'_, Bcsctl3Spec> {
                Lfxt1sW::new(self, 4)
            }
            #[doc = "Bits 6:7 - Mode 0 for XT2"]
            #[inline(always)]
            pub fn xt2s(&mut self) -> Xt2sW<'_, Bcsctl3Spec> {
                Xt2sW::new(self, 6)
            }
        }
        #[doc = "Basic Clock System Control 3\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Bcsctl3Spec;
        impl crate::RegisterSpec for Bcsctl3Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bcsctl3::R`](R) reader structure"]
        impl crate::Readable for Bcsctl3Spec {}
        #[doc = "`write(|w| ..)` method takes [`bcsctl3::W`](W) writer structure"]
        impl crate::Writable for Bcsctl3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BCSCTL3 to value 0"]
        impl crate::Resettable for Bcsctl3Spec {}
    }
    #[doc = "DCOCTL (rw) register accessor: DCO Clock Frequency Control\n\nYou can [`read`](crate::Reg::read) this register and get [`dcoctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcoctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcoctl`] module"]
    #[doc(alias = "DCOCTL")]
    pub type Dcoctl = crate::Reg<dcoctl::DcoctlSpec>;
    #[doc = "DCO Clock Frequency Control"]
    pub mod dcoctl {
        #[doc = "Register `DCOCTL` reader"]
        pub type R = crate::R<DcoctlSpec>;
        #[doc = "Register `DCOCTL` writer"]
        pub type W = crate::W<DcoctlSpec>;
        #[doc = "Field `MOD0` reader - Modulation Bit 0"]
        pub type Mod0R = crate::BitReader;
        #[doc = "Field `MOD0` writer - Modulation Bit 0"]
        pub type Mod0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOD1` reader - Modulation Bit 1"]
        pub type Mod1R = crate::BitReader;
        #[doc = "Field `MOD1` writer - Modulation Bit 1"]
        pub type Mod1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOD2` reader - Modulation Bit 2"]
        pub type Mod2R = crate::BitReader;
        #[doc = "Field `MOD2` writer - Modulation Bit 2"]
        pub type Mod2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOD3` reader - Modulation Bit 3"]
        pub type Mod3R = crate::BitReader;
        #[doc = "Field `MOD3` writer - Modulation Bit 3"]
        pub type Mod3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MOD4` reader - Modulation Bit 4"]
        pub type Mod4R = crate::BitReader;
        #[doc = "Field `MOD4` writer - Modulation Bit 4"]
        pub type Mod4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DCO0` reader - DCO Select Bit 0"]
        pub type Dco0R = crate::BitReader;
        #[doc = "Field `DCO0` writer - DCO Select Bit 0"]
        pub type Dco0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DCO1` reader - DCO Select Bit 1"]
        pub type Dco1R = crate::BitReader;
        #[doc = "Field `DCO1` writer - DCO Select Bit 1"]
        pub type Dco1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DCO2` reader - DCO Select Bit 2"]
        pub type Dco2R = crate::BitReader;
        #[doc = "Field `DCO2` writer - DCO Select Bit 2"]
        pub type Dco2W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Modulation Bit 0"]
            #[inline(always)]
            pub fn mod0(&self) -> Mod0R {
                Mod0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Modulation Bit 1"]
            #[inline(always)]
            pub fn mod1(&self) -> Mod1R {
                Mod1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Modulation Bit 2"]
            #[inline(always)]
            pub fn mod2(&self) -> Mod2R {
                Mod2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Modulation Bit 3"]
            #[inline(always)]
            pub fn mod3(&self) -> Mod3R {
                Mod3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Modulation Bit 4"]
            #[inline(always)]
            pub fn mod4(&self) -> Mod4R {
                Mod4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - DCO Select Bit 0"]
            #[inline(always)]
            pub fn dco0(&self) -> Dco0R {
                Dco0R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - DCO Select Bit 1"]
            #[inline(always)]
            pub fn dco1(&self) -> Dco1R {
                Dco1R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - DCO Select Bit 2"]
            #[inline(always)]
            pub fn dco2(&self) -> Dco2R {
                Dco2R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Modulation Bit 0"]
            #[inline(always)]
            pub fn mod0(&mut self) -> Mod0W<'_, DcoctlSpec> {
                Mod0W::new(self, 0)
            }
            #[doc = "Bit 1 - Modulation Bit 1"]
            #[inline(always)]
            pub fn mod1(&mut self) -> Mod1W<'_, DcoctlSpec> {
                Mod1W::new(self, 1)
            }
            #[doc = "Bit 2 - Modulation Bit 2"]
            #[inline(always)]
            pub fn mod2(&mut self) -> Mod2W<'_, DcoctlSpec> {
                Mod2W::new(self, 2)
            }
            #[doc = "Bit 3 - Modulation Bit 3"]
            #[inline(always)]
            pub fn mod3(&mut self) -> Mod3W<'_, DcoctlSpec> {
                Mod3W::new(self, 3)
            }
            #[doc = "Bit 4 - Modulation Bit 4"]
            #[inline(always)]
            pub fn mod4(&mut self) -> Mod4W<'_, DcoctlSpec> {
                Mod4W::new(self, 4)
            }
            #[doc = "Bit 5 - DCO Select Bit 0"]
            #[inline(always)]
            pub fn dco0(&mut self) -> Dco0W<'_, DcoctlSpec> {
                Dco0W::new(self, 5)
            }
            #[doc = "Bit 6 - DCO Select Bit 1"]
            #[inline(always)]
            pub fn dco1(&mut self) -> Dco1W<'_, DcoctlSpec> {
                Dco1W::new(self, 6)
            }
            #[doc = "Bit 7 - DCO Select Bit 2"]
            #[inline(always)]
            pub fn dco2(&mut self) -> Dco2W<'_, DcoctlSpec> {
                Dco2W::new(self, 7)
            }
        }
        #[doc = "DCO Clock Frequency Control\n\nYou can [`read`](crate::Reg::read) this register and get [`dcoctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcoctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DcoctlSpec;
        impl crate::RegisterSpec for DcoctlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dcoctl::R`](R) reader structure"]
        impl crate::Readable for DcoctlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dcoctl::W`](W) writer structure"]
        impl crate::Writable for DcoctlSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets DCOCTL to value 0"]
        impl crate::Resettable for DcoctlSpec {}
    }
    #[doc = "BCSCTL1 (rw) register accessor: Basic Clock System Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcsctl1`] module"]
    #[doc(alias = "BCSCTL1")]
    pub type Bcsctl1 = crate::Reg<bcsctl1::Bcsctl1Spec>;
    #[doc = "Basic Clock System Control 1"]
    pub mod bcsctl1 {
        #[doc = "Register `BCSCTL1` reader"]
        pub type R = crate::R<Bcsctl1Spec>;
        #[doc = "Register `BCSCTL1` writer"]
        pub type W = crate::W<Bcsctl1Spec>;
        #[doc = "Field `RSEL0` reader - Range Select Bit 0"]
        pub type Rsel0R = crate::BitReader;
        #[doc = "Field `RSEL0` writer - Range Select Bit 0"]
        pub type Rsel0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RSEL1` reader - Range Select Bit 1"]
        pub type Rsel1R = crate::BitReader;
        #[doc = "Field `RSEL1` writer - Range Select Bit 1"]
        pub type Rsel1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RSEL2` reader - Range Select Bit 2"]
        pub type Rsel2R = crate::BitReader;
        #[doc = "Field `RSEL2` writer - Range Select Bit 2"]
        pub type Rsel2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RSEL3` reader - Range Select Bit 3"]
        pub type Rsel3R = crate::BitReader;
        #[doc = "Field `RSEL3` writer - Range Select Bit 3"]
        pub type Rsel3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "ACLK Divider 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Diva {
            #[doc = "0: ACLK Divider 0: /1"]
            Diva0 = 0,
            #[doc = "1: ACLK Divider 1: /2"]
            Diva1 = 1,
            #[doc = "2: ACLK Divider 2: /4"]
            Diva2 = 2,
            #[doc = "3: ACLK Divider 3: /8"]
            Diva3 = 3,
        }
        impl From<Diva> for u8 {
            #[inline(always)]
            fn from(variant: Diva) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Diva {
            type Ux = u8;
        }
        impl crate::IsEnum for Diva {}
        #[doc = "Field `DIVA` reader - ACLK Divider 0"]
        pub type DivaR = crate::FieldReader<Diva>;
        impl DivaR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Diva {
                match self.bits {
                    0 => Diva::Diva0,
                    1 => Diva::Diva1,
                    2 => Diva::Diva2,
                    3 => Diva::Diva3,
                    _ => unreachable!(),
                }
            }
            #[doc = "ACLK Divider 0: /1"]
            #[inline(always)]
            pub fn is_diva_0(&self) -> bool {
                *self == Diva::Diva0
            }
            #[doc = "ACLK Divider 1: /2"]
            #[inline(always)]
            pub fn is_diva_1(&self) -> bool {
                *self == Diva::Diva1
            }
            #[doc = "ACLK Divider 2: /4"]
            #[inline(always)]
            pub fn is_diva_2(&self) -> bool {
                *self == Diva::Diva2
            }
            #[doc = "ACLK Divider 3: /8"]
            #[inline(always)]
            pub fn is_diva_3(&self) -> bool {
                *self == Diva::Diva3
            }
        }
        #[doc = "Field `DIVA` writer - ACLK Divider 0"]
        pub type DivaW<'a, REG> = crate::FieldWriter<'a, REG, 2, Diva, crate::Safe>;
        impl<'a, REG> DivaW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "ACLK Divider 0: /1"]
            #[inline(always)]
            pub fn diva_0(self) -> &'a mut crate::W<REG> {
                self.variant(Diva::Diva0)
            }
            #[doc = "ACLK Divider 1: /2"]
            #[inline(always)]
            pub fn diva_1(self) -> &'a mut crate::W<REG> {
                self.variant(Diva::Diva1)
            }
            #[doc = "ACLK Divider 2: /4"]
            #[inline(always)]
            pub fn diva_2(self) -> &'a mut crate::W<REG> {
                self.variant(Diva::Diva2)
            }
            #[doc = "ACLK Divider 3: /8"]
            #[inline(always)]
            pub fn diva_3(self) -> &'a mut crate::W<REG> {
                self.variant(Diva::Diva3)
            }
        }
        #[doc = "Field `XTS` reader - LFXTCLK 0:Low Freq. / 1: High Freq."]
        pub type XtsR = crate::BitReader;
        #[doc = "Field `XTS` writer - LFXTCLK 0:Low Freq. / 1: High Freq."]
        pub type XtsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `XT2OFF` reader - Enable XT2CLK"]
        pub type Xt2offR = crate::BitReader;
        #[doc = "Field `XT2OFF` writer - Enable XT2CLK"]
        pub type Xt2offW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Range Select Bit 0"]
            #[inline(always)]
            pub fn rsel0(&self) -> Rsel0R {
                Rsel0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Range Select Bit 1"]
            #[inline(always)]
            pub fn rsel1(&self) -> Rsel1R {
                Rsel1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Range Select Bit 2"]
            #[inline(always)]
            pub fn rsel2(&self) -> Rsel2R {
                Rsel2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Range Select Bit 3"]
            #[inline(always)]
            pub fn rsel3(&self) -> Rsel3R {
                Rsel3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - ACLK Divider 0"]
            #[inline(always)]
            pub fn diva(&self) -> DivaR {
                DivaR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - LFXTCLK 0:Low Freq. / 1: High Freq."]
            #[inline(always)]
            pub fn xts(&self) -> XtsR {
                XtsR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Enable XT2CLK"]
            #[inline(always)]
            pub fn xt2off(&self) -> Xt2offR {
                Xt2offR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Range Select Bit 0"]
            #[inline(always)]
            pub fn rsel0(&mut self) -> Rsel0W<'_, Bcsctl1Spec> {
                Rsel0W::new(self, 0)
            }
            #[doc = "Bit 1 - Range Select Bit 1"]
            #[inline(always)]
            pub fn rsel1(&mut self) -> Rsel1W<'_, Bcsctl1Spec> {
                Rsel1W::new(self, 1)
            }
            #[doc = "Bit 2 - Range Select Bit 2"]
            #[inline(always)]
            pub fn rsel2(&mut self) -> Rsel2W<'_, Bcsctl1Spec> {
                Rsel2W::new(self, 2)
            }
            #[doc = "Bit 3 - Range Select Bit 3"]
            #[inline(always)]
            pub fn rsel3(&mut self) -> Rsel3W<'_, Bcsctl1Spec> {
                Rsel3W::new(self, 3)
            }
            #[doc = "Bits 4:5 - ACLK Divider 0"]
            #[inline(always)]
            pub fn diva(&mut self) -> DivaW<'_, Bcsctl1Spec> {
                DivaW::new(self, 4)
            }
            #[doc = "Bit 6 - LFXTCLK 0:Low Freq. / 1: High Freq."]
            #[inline(always)]
            pub fn xts(&mut self) -> XtsW<'_, Bcsctl1Spec> {
                XtsW::new(self, 6)
            }
            #[doc = "Bit 7 - Enable XT2CLK"]
            #[inline(always)]
            pub fn xt2off(&mut self) -> Xt2offW<'_, Bcsctl1Spec> {
                Xt2offW::new(self, 7)
            }
        }
        #[doc = "Basic Clock System Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Bcsctl1Spec;
        impl crate::RegisterSpec for Bcsctl1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bcsctl1::R`](R) reader structure"]
        impl crate::Readable for Bcsctl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`bcsctl1::W`](W) writer structure"]
        impl crate::Writable for Bcsctl1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BCSCTL1 to value 0"]
        impl crate::Resettable for Bcsctl1Spec {}
    }
    #[doc = "BCSCTL2 (rw) register accessor: Basic Clock System Control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bcsctl2`] module"]
    #[doc(alias = "BCSCTL2")]
    pub type Bcsctl2 = crate::Reg<bcsctl2::Bcsctl2Spec>;
    #[doc = "Basic Clock System Control 2"]
    pub mod bcsctl2 {
        #[doc = "Register `BCSCTL2` reader"]
        pub type R = crate::R<Bcsctl2Spec>;
        #[doc = "Register `BCSCTL2` writer"]
        pub type W = crate::W<Bcsctl2Spec>;
        #[doc = "SMCLK Divider 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Divs {
            #[doc = "0: SMCLK Divider 0: /1"]
            Divs0 = 0,
            #[doc = "1: SMCLK Divider 1: /2"]
            Divs1 = 1,
            #[doc = "2: SMCLK Divider 2: /4"]
            Divs2 = 2,
            #[doc = "3: SMCLK Divider 3: /8"]
            Divs3 = 3,
        }
        impl From<Divs> for u8 {
            #[inline(always)]
            fn from(variant: Divs) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Divs {
            type Ux = u8;
        }
        impl crate::IsEnum for Divs {}
        #[doc = "Field `DIVS` reader - SMCLK Divider 0"]
        pub type DivsR = crate::FieldReader<Divs>;
        impl DivsR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Divs {
                match self.bits {
                    0 => Divs::Divs0,
                    1 => Divs::Divs1,
                    2 => Divs::Divs2,
                    3 => Divs::Divs3,
                    _ => unreachable!(),
                }
            }
            #[doc = "SMCLK Divider 0: /1"]
            #[inline(always)]
            pub fn is_divs_0(&self) -> bool {
                *self == Divs::Divs0
            }
            #[doc = "SMCLK Divider 1: /2"]
            #[inline(always)]
            pub fn is_divs_1(&self) -> bool {
                *self == Divs::Divs1
            }
            #[doc = "SMCLK Divider 2: /4"]
            #[inline(always)]
            pub fn is_divs_2(&self) -> bool {
                *self == Divs::Divs2
            }
            #[doc = "SMCLK Divider 3: /8"]
            #[inline(always)]
            pub fn is_divs_3(&self) -> bool {
                *self == Divs::Divs3
            }
        }
        #[doc = "Field `DIVS` writer - SMCLK Divider 0"]
        pub type DivsW<'a, REG> = crate::FieldWriter<'a, REG, 2, Divs, crate::Safe>;
        impl<'a, REG> DivsW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "SMCLK Divider 0: /1"]
            #[inline(always)]
            pub fn divs_0(self) -> &'a mut crate::W<REG> {
                self.variant(Divs::Divs0)
            }
            #[doc = "SMCLK Divider 1: /2"]
            #[inline(always)]
            pub fn divs_1(self) -> &'a mut crate::W<REG> {
                self.variant(Divs::Divs1)
            }
            #[doc = "SMCLK Divider 2: /4"]
            #[inline(always)]
            pub fn divs_2(self) -> &'a mut crate::W<REG> {
                self.variant(Divs::Divs2)
            }
            #[doc = "SMCLK Divider 3: /8"]
            #[inline(always)]
            pub fn divs_3(self) -> &'a mut crate::W<REG> {
                self.variant(Divs::Divs3)
            }
        }
        #[doc = "Field `SELS` reader - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
        pub type SelsR = crate::BitReader;
        #[doc = "Field `SELS` writer - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
        pub type SelsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "MCLK Divider 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Divm {
            #[doc = "0: MCLK Divider 0: /1"]
            Divm0 = 0,
            #[doc = "1: MCLK Divider 1: /2"]
            Divm1 = 1,
            #[doc = "2: MCLK Divider 2: /4"]
            Divm2 = 2,
            #[doc = "3: MCLK Divider 3: /8"]
            Divm3 = 3,
        }
        impl From<Divm> for u8 {
            #[inline(always)]
            fn from(variant: Divm) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Divm {
            type Ux = u8;
        }
        impl crate::IsEnum for Divm {}
        #[doc = "Field `DIVM` reader - MCLK Divider 0"]
        pub type DivmR = crate::FieldReader<Divm>;
        impl DivmR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Divm {
                match self.bits {
                    0 => Divm::Divm0,
                    1 => Divm::Divm1,
                    2 => Divm::Divm2,
                    3 => Divm::Divm3,
                    _ => unreachable!(),
                }
            }
            #[doc = "MCLK Divider 0: /1"]
            #[inline(always)]
            pub fn is_divm_0(&self) -> bool {
                *self == Divm::Divm0
            }
            #[doc = "MCLK Divider 1: /2"]
            #[inline(always)]
            pub fn is_divm_1(&self) -> bool {
                *self == Divm::Divm1
            }
            #[doc = "MCLK Divider 2: /4"]
            #[inline(always)]
            pub fn is_divm_2(&self) -> bool {
                *self == Divm::Divm2
            }
            #[doc = "MCLK Divider 3: /8"]
            #[inline(always)]
            pub fn is_divm_3(&self) -> bool {
                *self == Divm::Divm3
            }
        }
        #[doc = "Field `DIVM` writer - MCLK Divider 0"]
        pub type DivmW<'a, REG> = crate::FieldWriter<'a, REG, 2, Divm, crate::Safe>;
        impl<'a, REG> DivmW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "MCLK Divider 0: /1"]
            #[inline(always)]
            pub fn divm_0(self) -> &'a mut crate::W<REG> {
                self.variant(Divm::Divm0)
            }
            #[doc = "MCLK Divider 1: /2"]
            #[inline(always)]
            pub fn divm_1(self) -> &'a mut crate::W<REG> {
                self.variant(Divm::Divm1)
            }
            #[doc = "MCLK Divider 2: /4"]
            #[inline(always)]
            pub fn divm_2(self) -> &'a mut crate::W<REG> {
                self.variant(Divm::Divm2)
            }
            #[doc = "MCLK Divider 3: /8"]
            #[inline(always)]
            pub fn divm_3(self) -> &'a mut crate::W<REG> {
                self.variant(Divm::Divm3)
            }
        }
        #[doc = "MCLK Source Select 0\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Selm {
            #[doc = "0: MCLK Source Select 0: DCOCLK"]
            Selm0 = 0,
            #[doc = "1: MCLK Source Select 1: DCOCLK"]
            Selm1 = 1,
            #[doc = "2: MCLK Source Select 2: XT2CLK/LFXTCLK"]
            Selm2 = 2,
            #[doc = "3: MCLK Source Select 3: LFXTCLK"]
            Selm3 = 3,
        }
        impl From<Selm> for u8 {
            #[inline(always)]
            fn from(variant: Selm) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Selm {
            type Ux = u8;
        }
        impl crate::IsEnum for Selm {}
        #[doc = "Field `SELM` reader - MCLK Source Select 0"]
        pub type SelmR = crate::FieldReader<Selm>;
        impl SelmR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Selm {
                match self.bits {
                    0 => Selm::Selm0,
                    1 => Selm::Selm1,
                    2 => Selm::Selm2,
                    3 => Selm::Selm3,
                    _ => unreachable!(),
                }
            }
            #[doc = "MCLK Source Select 0: DCOCLK"]
            #[inline(always)]
            pub fn is_selm_0(&self) -> bool {
                *self == Selm::Selm0
            }
            #[doc = "MCLK Source Select 1: DCOCLK"]
            #[inline(always)]
            pub fn is_selm_1(&self) -> bool {
                *self == Selm::Selm1
            }
            #[doc = "MCLK Source Select 2: XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn is_selm_2(&self) -> bool {
                *self == Selm::Selm2
            }
            #[doc = "MCLK Source Select 3: LFXTCLK"]
            #[inline(always)]
            pub fn is_selm_3(&self) -> bool {
                *self == Selm::Selm3
            }
        }
        #[doc = "Field `SELM` writer - MCLK Source Select 0"]
        pub type SelmW<'a, REG> = crate::FieldWriter<'a, REG, 2, Selm, crate::Safe>;
        impl<'a, REG> SelmW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "MCLK Source Select 0: DCOCLK"]
            #[inline(always)]
            pub fn selm_0(self) -> &'a mut crate::W<REG> {
                self.variant(Selm::Selm0)
            }
            #[doc = "MCLK Source Select 1: DCOCLK"]
            #[inline(always)]
            pub fn selm_1(self) -> &'a mut crate::W<REG> {
                self.variant(Selm::Selm1)
            }
            #[doc = "MCLK Source Select 2: XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn selm_2(self) -> &'a mut crate::W<REG> {
                self.variant(Selm::Selm2)
            }
            #[doc = "MCLK Source Select 3: LFXTCLK"]
            #[inline(always)]
            pub fn selm_3(self) -> &'a mut crate::W<REG> {
                self.variant(Selm::Selm3)
            }
        }
        impl R {
            #[doc = "Bits 1:2 - SMCLK Divider 0"]
            #[inline(always)]
            pub fn divs(&self) -> DivsR {
                DivsR::new((self.bits >> 1) & 3)
            }
            #[doc = "Bit 3 - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn sels(&self) -> SelsR {
                SelsR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - MCLK Divider 0"]
            #[inline(always)]
            pub fn divm(&self) -> DivmR {
                DivmR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bits 6:7 - MCLK Source Select 0"]
            #[inline(always)]
            pub fn selm(&self) -> SelmR {
                SelmR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bits 1:2 - SMCLK Divider 0"]
            #[inline(always)]
            pub fn divs(&mut self) -> DivsW<'_, Bcsctl2Spec> {
                DivsW::new(self, 1)
            }
            #[doc = "Bit 3 - SMCLK Source Select 0:DCOCLK / 1:XT2CLK/LFXTCLK"]
            #[inline(always)]
            pub fn sels(&mut self) -> SelsW<'_, Bcsctl2Spec> {
                SelsW::new(self, 3)
            }
            #[doc = "Bits 4:5 - MCLK Divider 0"]
            #[inline(always)]
            pub fn divm(&mut self) -> DivmW<'_, Bcsctl2Spec> {
                DivmW::new(self, 4)
            }
            #[doc = "Bits 6:7 - MCLK Source Select 0"]
            #[inline(always)]
            pub fn selm(&mut self) -> SelmW<'_, Bcsctl2Spec> {
                SelmW::new(self, 6)
            }
        }
        #[doc = "Basic Clock System Control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`bcsctl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bcsctl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Bcsctl2Spec;
        impl crate::RegisterSpec for Bcsctl2Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bcsctl2::R`](R) reader structure"]
        impl crate::Readable for Bcsctl2Spec {}
        #[doc = "`write(|w| ..)` method takes [`bcsctl2::W`](W) writer structure"]
        impl crate::Writable for Bcsctl2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BCSCTL2 to value 0"]
        impl crate::Resettable for Bcsctl2Spec {}
    }
}
#[doc = "USI"]
pub type Usi = crate::Periph<usi::RegisterBlock, 0x78>;
impl core::fmt::Debug for Usi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usi").finish()
    }
}
#[doc = "USI"]
pub mod usi {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        usictl0: Usictl0,
        usictl1: Usictl1,
        usickctl: Usickctl,
        usicnt: Usicnt,
        usisrl: Usisrl,
        usisrh: Usisrh,
    }
    impl RegisterBlock {
        #[doc = "0x00 - USI Control Register 0"]
        #[inline(always)]
        pub const fn usictl0(&self) -> &Usictl0 {
            &self.usictl0
        }
        #[doc = "0x01 - USI Control Register 1"]
        #[inline(always)]
        pub const fn usictl1(&self) -> &Usictl1 {
            &self.usictl1
        }
        #[doc = "0x02 - USI Clock Control Register"]
        #[inline(always)]
        pub const fn usickctl(&self) -> &Usickctl {
            &self.usickctl
        }
        #[doc = "0x03 - USI Bit Counter Register"]
        #[inline(always)]
        pub const fn usicnt(&self) -> &Usicnt {
            &self.usicnt
        }
        #[doc = "0x04 - USI Low Byte Shift Register"]
        #[inline(always)]
        pub const fn usisrl(&self) -> &Usisrl {
            &self.usisrl
        }
        #[doc = "0x05 - USI High Byte Shift Register"]
        #[inline(always)]
        pub const fn usisrh(&self) -> &Usisrh {
            &self.usisrh
        }
    }
    #[doc = "USICTL0 (rw) register accessor: USI Control Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`usictl0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usictl0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usictl0`] module"]
    #[doc(alias = "USICTL0")]
    pub type Usictl0 = crate::Reg<usictl0::Usictl0Spec>;
    #[doc = "USI Control Register 0"]
    pub mod usictl0 {
        #[doc = "Register `USICTL0` reader"]
        pub type R = crate::R<Usictl0Spec>;
        #[doc = "Register `USICTL0` writer"]
        pub type W = crate::W<Usictl0Spec>;
        #[doc = "Field `USISWRST` reader - USI Software Reset"]
        pub type UsiswrstR = crate::BitReader;
        #[doc = "Field `USISWRST` writer - USI Software Reset"]
        pub type UsiswrstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIOE` reader - USI Output Enable"]
        pub type UsioeR = crate::BitReader;
        #[doc = "Field `USIOE` writer - USI Output Enable"]
        pub type UsioeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIGE` reader - USI General Output Enable Latch"]
        pub type UsigeR = crate::BitReader;
        #[doc = "Field `USIGE` writer - USI General Output Enable Latch"]
        pub type UsigeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIMST` reader - USI Master Select 0:Slave / 1:Master"]
        pub type UsimstR = crate::BitReader;
        #[doc = "Field `USIMST` writer - USI Master Select 0:Slave / 1:Master"]
        pub type UsimstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USILSB` reader - USI LSB first 1:LSB / 0:MSB"]
        pub type UsilsbR = crate::BitReader;
        #[doc = "Field `USILSB` writer - USI LSB first 1:LSB / 0:MSB"]
        pub type UsilsbW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIPE5` reader - USI Port Enable Px.5"]
        pub type Usipe5R = crate::BitReader;
        #[doc = "Field `USIPE5` writer - USI Port Enable Px.5"]
        pub type Usipe5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIPE6` reader - USI Port Enable Px.6"]
        pub type Usipe6R = crate::BitReader;
        #[doc = "Field `USIPE6` writer - USI Port Enable Px.6"]
        pub type Usipe6W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIPE7` reader - USI Port Enable Px.7"]
        pub type Usipe7R = crate::BitReader;
        #[doc = "Field `USIPE7` writer - USI Port Enable Px.7"]
        pub type Usipe7W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - USI Software Reset"]
            #[inline(always)]
            pub fn usiswrst(&self) -> UsiswrstR {
                UsiswrstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - USI Output Enable"]
            #[inline(always)]
            pub fn usioe(&self) -> UsioeR {
                UsioeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - USI General Output Enable Latch"]
            #[inline(always)]
            pub fn usige(&self) -> UsigeR {
                UsigeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - USI Master Select 0:Slave / 1:Master"]
            #[inline(always)]
            pub fn usimst(&self) -> UsimstR {
                UsimstR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - USI LSB first 1:LSB / 0:MSB"]
            #[inline(always)]
            pub fn usilsb(&self) -> UsilsbR {
                UsilsbR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - USI Port Enable Px.5"]
            #[inline(always)]
            pub fn usipe5(&self) -> Usipe5R {
                Usipe5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - USI Port Enable Px.6"]
            #[inline(always)]
            pub fn usipe6(&self) -> Usipe6R {
                Usipe6R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - USI Port Enable Px.7"]
            #[inline(always)]
            pub fn usipe7(&self) -> Usipe7R {
                Usipe7R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - USI Software Reset"]
            #[inline(always)]
            pub fn usiswrst(&mut self) -> UsiswrstW<'_, Usictl0Spec> {
                UsiswrstW::new(self, 0)
            }
            #[doc = "Bit 1 - USI Output Enable"]
            #[inline(always)]
            pub fn usioe(&mut self) -> UsioeW<'_, Usictl0Spec> {
                UsioeW::new(self, 1)
            }
            #[doc = "Bit 2 - USI General Output Enable Latch"]
            #[inline(always)]
            pub fn usige(&mut self) -> UsigeW<'_, Usictl0Spec> {
                UsigeW::new(self, 2)
            }
            #[doc = "Bit 3 - USI Master Select 0:Slave / 1:Master"]
            #[inline(always)]
            pub fn usimst(&mut self) -> UsimstW<'_, Usictl0Spec> {
                UsimstW::new(self, 3)
            }
            #[doc = "Bit 4 - USI LSB first 1:LSB / 0:MSB"]
            #[inline(always)]
            pub fn usilsb(&mut self) -> UsilsbW<'_, Usictl0Spec> {
                UsilsbW::new(self, 4)
            }
            #[doc = "Bit 5 - USI Port Enable Px.5"]
            #[inline(always)]
            pub fn usipe5(&mut self) -> Usipe5W<'_, Usictl0Spec> {
                Usipe5W::new(self, 5)
            }
            #[doc = "Bit 6 - USI Port Enable Px.6"]
            #[inline(always)]
            pub fn usipe6(&mut self) -> Usipe6W<'_, Usictl0Spec> {
                Usipe6W::new(self, 6)
            }
            #[doc = "Bit 7 - USI Port Enable Px.7"]
            #[inline(always)]
            pub fn usipe7(&mut self) -> Usipe7W<'_, Usictl0Spec> {
                Usipe7W::new(self, 7)
            }
        }
        #[doc = "USI Control Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`usictl0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usictl0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Usictl0Spec;
        impl crate::RegisterSpec for Usictl0Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usictl0::R`](R) reader structure"]
        impl crate::Readable for Usictl0Spec {}
        #[doc = "`write(|w| ..)` method takes [`usictl0::W`](W) writer structure"]
        impl crate::Writable for Usictl0Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets USICTL0 to value 0"]
        impl crate::Resettable for Usictl0Spec {}
    }
    #[doc = "USICTL1 (rw) register accessor: USI Control Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`usictl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usictl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usictl1`] module"]
    #[doc(alias = "USICTL1")]
    pub type Usictl1 = crate::Reg<usictl1::Usictl1Spec>;
    #[doc = "USI Control Register 1"]
    pub mod usictl1 {
        #[doc = "Register `USICTL1` reader"]
        pub type R = crate::R<Usictl1Spec>;
        #[doc = "Register `USICTL1` writer"]
        pub type W = crate::W<Usictl1Spec>;
        #[doc = "Field `USIIFG` reader - USI Counter Interrupt Flag"]
        pub type UsiifgR = crate::BitReader;
        #[doc = "Field `USIIFG` writer - USI Counter Interrupt Flag"]
        pub type UsiifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USISTTIFG` reader - USI START Condition interrupt Flag"]
        pub type UsisttifgR = crate::BitReader;
        #[doc = "Field `USISTTIFG` writer - USI START Condition interrupt Flag"]
        pub type UsisttifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USISTP` reader - USI STOP Condition received"]
        pub type UsistpR = crate::BitReader;
        #[doc = "Field `USISTP` writer - USI STOP Condition received"]
        pub type UsistpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIAL` reader - USI Arbitration Lost"]
        pub type UsialR = crate::BitReader;
        #[doc = "Field `USIAL` writer - USI Arbitration Lost"]
        pub type UsialW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIIE` reader - USI Counter Interrupt enable"]
        pub type UsiieR = crate::BitReader;
        #[doc = "Field `USIIE` writer - USI Counter Interrupt enable"]
        pub type UsiieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USISTTIE` reader - USI START Condition interrupt enable"]
        pub type UsisttieR = crate::BitReader;
        #[doc = "Field `USISTTIE` writer - USI START Condition interrupt enable"]
        pub type UsisttieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USII2C` reader - USI I2C Mode"]
        pub type Usii2cR = crate::BitReader;
        #[doc = "Field `USII2C` writer - USI I2C Mode"]
        pub type Usii2cW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICKPH` reader - USI Sync. Mode: Clock Phase"]
        pub type UsickphR = crate::BitReader;
        #[doc = "Field `USICKPH` writer - USI Sync. Mode: Clock Phase"]
        pub type UsickphW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - USI Counter Interrupt Flag"]
            #[inline(always)]
            pub fn usiifg(&self) -> UsiifgR {
                UsiifgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - USI START Condition interrupt Flag"]
            #[inline(always)]
            pub fn usisttifg(&self) -> UsisttifgR {
                UsisttifgR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - USI STOP Condition received"]
            #[inline(always)]
            pub fn usistp(&self) -> UsistpR {
                UsistpR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - USI Arbitration Lost"]
            #[inline(always)]
            pub fn usial(&self) -> UsialR {
                UsialR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - USI Counter Interrupt enable"]
            #[inline(always)]
            pub fn usiie(&self) -> UsiieR {
                UsiieR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - USI START Condition interrupt enable"]
            #[inline(always)]
            pub fn usisttie(&self) -> UsisttieR {
                UsisttieR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - USI I2C Mode"]
            #[inline(always)]
            pub fn usii2c(&self) -> Usii2cR {
                Usii2cR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - USI Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn usickph(&self) -> UsickphR {
                UsickphR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - USI Counter Interrupt Flag"]
            #[inline(always)]
            pub fn usiifg(&mut self) -> UsiifgW<'_, Usictl1Spec> {
                UsiifgW::new(self, 0)
            }
            #[doc = "Bit 1 - USI START Condition interrupt Flag"]
            #[inline(always)]
            pub fn usisttifg(&mut self) -> UsisttifgW<'_, Usictl1Spec> {
                UsisttifgW::new(self, 1)
            }
            #[doc = "Bit 2 - USI STOP Condition received"]
            #[inline(always)]
            pub fn usistp(&mut self) -> UsistpW<'_, Usictl1Spec> {
                UsistpW::new(self, 2)
            }
            #[doc = "Bit 3 - USI Arbitration Lost"]
            #[inline(always)]
            pub fn usial(&mut self) -> UsialW<'_, Usictl1Spec> {
                UsialW::new(self, 3)
            }
            #[doc = "Bit 4 - USI Counter Interrupt enable"]
            #[inline(always)]
            pub fn usiie(&mut self) -> UsiieW<'_, Usictl1Spec> {
                UsiieW::new(self, 4)
            }
            #[doc = "Bit 5 - USI START Condition interrupt enable"]
            #[inline(always)]
            pub fn usisttie(&mut self) -> UsisttieW<'_, Usictl1Spec> {
                UsisttieW::new(self, 5)
            }
            #[doc = "Bit 6 - USI I2C Mode"]
            #[inline(always)]
            pub fn usii2c(&mut self) -> Usii2cW<'_, Usictl1Spec> {
                Usii2cW::new(self, 6)
            }
            #[doc = "Bit 7 - USI Sync. Mode: Clock Phase"]
            #[inline(always)]
            pub fn usickph(&mut self) -> UsickphW<'_, Usictl1Spec> {
                UsickphW::new(self, 7)
            }
        }
        #[doc = "USI Control Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`usictl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usictl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Usictl1Spec;
        impl crate::RegisterSpec for Usictl1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usictl1::R`](R) reader structure"]
        impl crate::Readable for Usictl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`usictl1::W`](W) writer structure"]
        impl crate::Writable for Usictl1Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets USICTL1 to value 0"]
        impl crate::Resettable for Usictl1Spec {}
    }
    #[doc = "USICKCTL (rw) register accessor: USI Clock Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usickctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usickctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usickctl`] module"]
    #[doc(alias = "USICKCTL")]
    pub type Usickctl = crate::Reg<usickctl::UsickctlSpec>;
    #[doc = "USI Clock Control Register"]
    pub mod usickctl {
        #[doc = "Register `USICKCTL` reader"]
        pub type R = crate::R<UsickctlSpec>;
        #[doc = "Register `USICKCTL` writer"]
        pub type W = crate::W<UsickctlSpec>;
        #[doc = "Field `USISWCLK` reader - USI Software Clock"]
        pub type UsiswclkR = crate::BitReader;
        #[doc = "Field `USISWCLK` writer - USI Software Clock"]
        pub type UsiswclkW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICKPL` reader - USI Clock Polarity 0:Inactive=Low / 1:Inactive=High"]
        pub type UsickplR = crate::BitReader;
        #[doc = "Field `USICKPL` writer - USI Clock Polarity 0:Inactive=Low / 1:Inactive=High"]
        pub type UsickplW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "USI Clock Source Select 2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Usissel {
            #[doc = "0: USI Clock Source: 0"]
            Usissel0 = 0,
            #[doc = "1: USI Clock Source: 1"]
            Usissel1 = 1,
            #[doc = "2: USI Clock Source: 2"]
            Usissel2 = 2,
            #[doc = "3: USI Clock Source: 3"]
            Usissel3 = 3,
            #[doc = "4: USI Clock Source: 4"]
            Usissel4 = 4,
            #[doc = "5: USI Clock Source: 5"]
            Usissel5 = 5,
            #[doc = "6: USI Clock Source: 6"]
            Usissel6 = 6,
            #[doc = "7: USI Clock Source: 7"]
            Usissel7 = 7,
        }
        impl From<Usissel> for u8 {
            #[inline(always)]
            fn from(variant: Usissel) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Usissel {
            type Ux = u8;
        }
        impl crate::IsEnum for Usissel {}
        #[doc = "Field `USISSEL` reader - USI Clock Source Select 2"]
        pub type UsisselR = crate::FieldReader<Usissel>;
        impl UsisselR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Usissel {
                match self.bits {
                    0 => Usissel::Usissel0,
                    1 => Usissel::Usissel1,
                    2 => Usissel::Usissel2,
                    3 => Usissel::Usissel3,
                    4 => Usissel::Usissel4,
                    5 => Usissel::Usissel5,
                    6 => Usissel::Usissel6,
                    7 => Usissel::Usissel7,
                    _ => unreachable!(),
                }
            }
            #[doc = "USI Clock Source: 0"]
            #[inline(always)]
            pub fn is_usissel_0(&self) -> bool {
                *self == Usissel::Usissel0
            }
            #[doc = "USI Clock Source: 1"]
            #[inline(always)]
            pub fn is_usissel_1(&self) -> bool {
                *self == Usissel::Usissel1
            }
            #[doc = "USI Clock Source: 2"]
            #[inline(always)]
            pub fn is_usissel_2(&self) -> bool {
                *self == Usissel::Usissel2
            }
            #[doc = "USI Clock Source: 3"]
            #[inline(always)]
            pub fn is_usissel_3(&self) -> bool {
                *self == Usissel::Usissel3
            }
            #[doc = "USI Clock Source: 4"]
            #[inline(always)]
            pub fn is_usissel_4(&self) -> bool {
                *self == Usissel::Usissel4
            }
            #[doc = "USI Clock Source: 5"]
            #[inline(always)]
            pub fn is_usissel_5(&self) -> bool {
                *self == Usissel::Usissel5
            }
            #[doc = "USI Clock Source: 6"]
            #[inline(always)]
            pub fn is_usissel_6(&self) -> bool {
                *self == Usissel::Usissel6
            }
            #[doc = "USI Clock Source: 7"]
            #[inline(always)]
            pub fn is_usissel_7(&self) -> bool {
                *self == Usissel::Usissel7
            }
        }
        #[doc = "Field `USISSEL` writer - USI Clock Source Select 2"]
        pub type UsisselW<'a, REG> = crate::FieldWriter<'a, REG, 3, Usissel, crate::Safe>;
        impl<'a, REG> UsisselW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "USI Clock Source: 0"]
            #[inline(always)]
            pub fn usissel_0(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel0)
            }
            #[doc = "USI Clock Source: 1"]
            #[inline(always)]
            pub fn usissel_1(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel1)
            }
            #[doc = "USI Clock Source: 2"]
            #[inline(always)]
            pub fn usissel_2(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel2)
            }
            #[doc = "USI Clock Source: 3"]
            #[inline(always)]
            pub fn usissel_3(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel3)
            }
            #[doc = "USI Clock Source: 4"]
            #[inline(always)]
            pub fn usissel_4(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel4)
            }
            #[doc = "USI Clock Source: 5"]
            #[inline(always)]
            pub fn usissel_5(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel5)
            }
            #[doc = "USI Clock Source: 6"]
            #[inline(always)]
            pub fn usissel_6(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel6)
            }
            #[doc = "USI Clock Source: 7"]
            #[inline(always)]
            pub fn usissel_7(self) -> &'a mut crate::W<REG> {
                self.variant(Usissel::Usissel7)
            }
        }
        #[doc = "USI Clock Divider 2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Usidiv {
            #[doc = "0: USI Clock Divider: 0"]
            Usidiv0 = 0,
            #[doc = "1: USI Clock Divider: 1"]
            Usidiv1 = 1,
            #[doc = "2: USI Clock Divider: 2"]
            Usidiv2 = 2,
            #[doc = "3: USI Clock Divider: 3"]
            Usidiv3 = 3,
            #[doc = "4: USI Clock Divider: 4"]
            Usidiv4 = 4,
            #[doc = "5: USI Clock Divider: 5"]
            Usidiv5 = 5,
            #[doc = "6: USI Clock Divider: 6"]
            Usidiv6 = 6,
            #[doc = "7: USI Clock Divider: 7"]
            Usidiv7 = 7,
        }
        impl From<Usidiv> for u8 {
            #[inline(always)]
            fn from(variant: Usidiv) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Usidiv {
            type Ux = u8;
        }
        impl crate::IsEnum for Usidiv {}
        #[doc = "Field `USIDIV` reader - USI Clock Divider 2"]
        pub type UsidivR = crate::FieldReader<Usidiv>;
        impl UsidivR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Usidiv {
                match self.bits {
                    0 => Usidiv::Usidiv0,
                    1 => Usidiv::Usidiv1,
                    2 => Usidiv::Usidiv2,
                    3 => Usidiv::Usidiv3,
                    4 => Usidiv::Usidiv4,
                    5 => Usidiv::Usidiv5,
                    6 => Usidiv::Usidiv6,
                    7 => Usidiv::Usidiv7,
                    _ => unreachable!(),
                }
            }
            #[doc = "USI Clock Divider: 0"]
            #[inline(always)]
            pub fn is_usidiv_0(&self) -> bool {
                *self == Usidiv::Usidiv0
            }
            #[doc = "USI Clock Divider: 1"]
            #[inline(always)]
            pub fn is_usidiv_1(&self) -> bool {
                *self == Usidiv::Usidiv1
            }
            #[doc = "USI Clock Divider: 2"]
            #[inline(always)]
            pub fn is_usidiv_2(&self) -> bool {
                *self == Usidiv::Usidiv2
            }
            #[doc = "USI Clock Divider: 3"]
            #[inline(always)]
            pub fn is_usidiv_3(&self) -> bool {
                *self == Usidiv::Usidiv3
            }
            #[doc = "USI Clock Divider: 4"]
            #[inline(always)]
            pub fn is_usidiv_4(&self) -> bool {
                *self == Usidiv::Usidiv4
            }
            #[doc = "USI Clock Divider: 5"]
            #[inline(always)]
            pub fn is_usidiv_5(&self) -> bool {
                *self == Usidiv::Usidiv5
            }
            #[doc = "USI Clock Divider: 6"]
            #[inline(always)]
            pub fn is_usidiv_6(&self) -> bool {
                *self == Usidiv::Usidiv6
            }
            #[doc = "USI Clock Divider: 7"]
            #[inline(always)]
            pub fn is_usidiv_7(&self) -> bool {
                *self == Usidiv::Usidiv7
            }
        }
        #[doc = "Field `USIDIV` writer - USI Clock Divider 2"]
        pub type UsidivW<'a, REG> = crate::FieldWriter<'a, REG, 3, Usidiv, crate::Safe>;
        impl<'a, REG> UsidivW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "USI Clock Divider: 0"]
            #[inline(always)]
            pub fn usidiv_0(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv0)
            }
            #[doc = "USI Clock Divider: 1"]
            #[inline(always)]
            pub fn usidiv_1(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv1)
            }
            #[doc = "USI Clock Divider: 2"]
            #[inline(always)]
            pub fn usidiv_2(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv2)
            }
            #[doc = "USI Clock Divider: 3"]
            #[inline(always)]
            pub fn usidiv_3(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv3)
            }
            #[doc = "USI Clock Divider: 4"]
            #[inline(always)]
            pub fn usidiv_4(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv4)
            }
            #[doc = "USI Clock Divider: 5"]
            #[inline(always)]
            pub fn usidiv_5(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv5)
            }
            #[doc = "USI Clock Divider: 6"]
            #[inline(always)]
            pub fn usidiv_6(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv6)
            }
            #[doc = "USI Clock Divider: 7"]
            #[inline(always)]
            pub fn usidiv_7(self) -> &'a mut crate::W<REG> {
                self.variant(Usidiv::Usidiv7)
            }
        }
        impl R {
            #[doc = "Bit 0 - USI Software Clock"]
            #[inline(always)]
            pub fn usiswclk(&self) -> UsiswclkR {
                UsiswclkR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - USI Clock Polarity 0:Inactive=Low / 1:Inactive=High"]
            #[inline(always)]
            pub fn usickpl(&self) -> UsickplR {
                UsickplR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:4 - USI Clock Source Select 2"]
            #[inline(always)]
            pub fn usissel(&self) -> UsisselR {
                UsisselR::new((self.bits >> 2) & 7)
            }
            #[doc = "Bits 5:7 - USI Clock Divider 2"]
            #[inline(always)]
            pub fn usidiv(&self) -> UsidivR {
                UsidivR::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            #[doc = "Bit 0 - USI Software Clock"]
            #[inline(always)]
            pub fn usiswclk(&mut self) -> UsiswclkW<'_, UsickctlSpec> {
                UsiswclkW::new(self, 0)
            }
            #[doc = "Bit 1 - USI Clock Polarity 0:Inactive=Low / 1:Inactive=High"]
            #[inline(always)]
            pub fn usickpl(&mut self) -> UsickplW<'_, UsickctlSpec> {
                UsickplW::new(self, 1)
            }
            #[doc = "Bits 2:4 - USI Clock Source Select 2"]
            #[inline(always)]
            pub fn usissel(&mut self) -> UsisselW<'_, UsickctlSpec> {
                UsisselW::new(self, 2)
            }
            #[doc = "Bits 5:7 - USI Clock Divider 2"]
            #[inline(always)]
            pub fn usidiv(&mut self) -> UsidivW<'_, UsickctlSpec> {
                UsidivW::new(self, 5)
            }
        }
        #[doc = "USI Clock Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usickctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usickctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UsickctlSpec;
        impl crate::RegisterSpec for UsickctlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usickctl::R`](R) reader structure"]
        impl crate::Readable for UsickctlSpec {}
        #[doc = "`write(|w| ..)` method takes [`usickctl::W`](W) writer structure"]
        impl crate::Writable for UsickctlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets USICKCTL to value 0"]
        impl crate::Resettable for UsickctlSpec {}
    }
    #[doc = "USICNT (rw) register accessor: USI Bit Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usicnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usicnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usicnt`] module"]
    #[doc(alias = "USICNT")]
    pub type Usicnt = crate::Reg<usicnt::UsicntSpec>;
    #[doc = "USI Bit Counter Register"]
    pub mod usicnt {
        #[doc = "Register `USICNT` reader"]
        pub type R = crate::R<UsicntSpec>;
        #[doc = "Register `USICNT` writer"]
        pub type W = crate::W<UsicntSpec>;
        #[doc = "Field `USICNT0` reader - USI Bit Count 0"]
        pub type Usicnt0R = crate::BitReader;
        #[doc = "Field `USICNT0` writer - USI Bit Count 0"]
        pub type Usicnt0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICNT1` reader - USI Bit Count 1"]
        pub type Usicnt1R = crate::BitReader;
        #[doc = "Field `USICNT1` writer - USI Bit Count 1"]
        pub type Usicnt1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICNT2` reader - USI Bit Count 2"]
        pub type Usicnt2R = crate::BitReader;
        #[doc = "Field `USICNT2` writer - USI Bit Count 2"]
        pub type Usicnt2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICNT3` reader - USI Bit Count 3"]
        pub type Usicnt3R = crate::BitReader;
        #[doc = "Field `USICNT3` writer - USI Bit Count 3"]
        pub type Usicnt3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USICNT4` reader - USI Bit Count 4"]
        pub type Usicnt4R = crate::BitReader;
        #[doc = "Field `USICNT4` writer - USI Bit Count 4"]
        pub type Usicnt4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USIIFGCC` reader - USI Interrupt Flag Clear Control"]
        pub type UsiifgccR = crate::BitReader;
        #[doc = "Field `USIIFGCC` writer - USI Interrupt Flag Clear Control"]
        pub type UsiifgccW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USI16B` reader - USI 16 Bit Shift Register Enable"]
        pub type Usi16bR = crate::BitReader;
        #[doc = "Field `USI16B` writer - USI 16 Bit Shift Register Enable"]
        pub type Usi16bW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `USISCLREL` reader - USI SCL Released"]
        pub type UsisclrelR = crate::BitReader;
        #[doc = "Field `USISCLREL` writer - USI SCL Released"]
        pub type UsisclrelW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - USI Bit Count 0"]
            #[inline(always)]
            pub fn usicnt0(&self) -> Usicnt0R {
                Usicnt0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - USI Bit Count 1"]
            #[inline(always)]
            pub fn usicnt1(&self) -> Usicnt1R {
                Usicnt1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - USI Bit Count 2"]
            #[inline(always)]
            pub fn usicnt2(&self) -> Usicnt2R {
                Usicnt2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - USI Bit Count 3"]
            #[inline(always)]
            pub fn usicnt3(&self) -> Usicnt3R {
                Usicnt3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - USI Bit Count 4"]
            #[inline(always)]
            pub fn usicnt4(&self) -> Usicnt4R {
                Usicnt4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - USI Interrupt Flag Clear Control"]
            #[inline(always)]
            pub fn usiifgcc(&self) -> UsiifgccR {
                UsiifgccR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - USI 16 Bit Shift Register Enable"]
            #[inline(always)]
            pub fn usi16b(&self) -> Usi16bR {
                Usi16bR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - USI SCL Released"]
            #[inline(always)]
            pub fn usisclrel(&self) -> UsisclrelR {
                UsisclrelR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - USI Bit Count 0"]
            #[inline(always)]
            pub fn usicnt0(&mut self) -> Usicnt0W<'_, UsicntSpec> {
                Usicnt0W::new(self, 0)
            }
            #[doc = "Bit 1 - USI Bit Count 1"]
            #[inline(always)]
            pub fn usicnt1(&mut self) -> Usicnt1W<'_, UsicntSpec> {
                Usicnt1W::new(self, 1)
            }
            #[doc = "Bit 2 - USI Bit Count 2"]
            #[inline(always)]
            pub fn usicnt2(&mut self) -> Usicnt2W<'_, UsicntSpec> {
                Usicnt2W::new(self, 2)
            }
            #[doc = "Bit 3 - USI Bit Count 3"]
            #[inline(always)]
            pub fn usicnt3(&mut self) -> Usicnt3W<'_, UsicntSpec> {
                Usicnt3W::new(self, 3)
            }
            #[doc = "Bit 4 - USI Bit Count 4"]
            #[inline(always)]
            pub fn usicnt4(&mut self) -> Usicnt4W<'_, UsicntSpec> {
                Usicnt4W::new(self, 4)
            }
            #[doc = "Bit 5 - USI Interrupt Flag Clear Control"]
            #[inline(always)]
            pub fn usiifgcc(&mut self) -> UsiifgccW<'_, UsicntSpec> {
                UsiifgccW::new(self, 5)
            }
            #[doc = "Bit 6 - USI 16 Bit Shift Register Enable"]
            #[inline(always)]
            pub fn usi16b(&mut self) -> Usi16bW<'_, UsicntSpec> {
                Usi16bW::new(self, 6)
            }
            #[doc = "Bit 7 - USI SCL Released"]
            #[inline(always)]
            pub fn usisclrel(&mut self) -> UsisclrelW<'_, UsicntSpec> {
                UsisclrelW::new(self, 7)
            }
        }
        #[doc = "USI Bit Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usicnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usicnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UsicntSpec;
        impl crate::RegisterSpec for UsicntSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usicnt::R`](R) reader structure"]
        impl crate::Readable for UsicntSpec {}
        #[doc = "`write(|w| ..)` method takes [`usicnt::W`](W) writer structure"]
        impl crate::Writable for UsicntSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets USICNT to value 0"]
        impl crate::Resettable for UsicntSpec {}
    }
    #[doc = "USISRL (rw) register accessor: USI Low Byte Shift Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usisrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usisrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usisrl`] module"]
    #[doc(alias = "USISRL")]
    pub type Usisrl = crate::Reg<usisrl::UsisrlSpec>;
    #[doc = "USI Low Byte Shift Register"]
    pub mod usisrl {
        #[doc = "Register `USISRL` reader"]
        pub type R = crate::R<UsisrlSpec>;
        #[doc = "Register `USISRL` writer"]
        pub type W = crate::W<UsisrlSpec>;
        #[doc = "Field `USISRL` reader - USI Low Byte Shift Register"]
        pub type UsisrlR = crate::FieldReader;
        #[doc = "Field `USISRL` writer - USI Low Byte Shift Register"]
        pub type UsisrlW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - USI Low Byte Shift Register"]
            #[inline(always)]
            pub fn usisrl(&self) -> UsisrlR {
                UsisrlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - USI Low Byte Shift Register"]
            #[inline(always)]
            pub fn usisrl(&mut self) -> UsisrlW<'_, UsisrlSpec> {
                UsisrlW::new(self, 0)
            }
        }
        #[doc = "USI Low Byte Shift Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usisrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usisrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UsisrlSpec;
        impl crate::RegisterSpec for UsisrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usisrl::R`](R) reader structure"]
        impl crate::Readable for UsisrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`usisrl::W`](W) writer structure"]
        impl crate::Writable for UsisrlSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets USISRL to value 0"]
        impl crate::Resettable for UsisrlSpec {}
    }
    #[doc = "USISRH (rw) register accessor: USI High Byte Shift Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usisrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usisrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@usisrh`] module"]
    #[doc(alias = "USISRH")]
    pub type Usisrh = crate::Reg<usisrh::UsisrhSpec>;
    #[doc = "USI High Byte Shift Register"]
    pub mod usisrh {
        #[doc = "Register `USISRH` reader"]
        pub type R = crate::R<UsisrhSpec>;
        #[doc = "Register `USISRH` writer"]
        pub type W = crate::W<UsisrhSpec>;
        #[doc = "Field `USISRH` reader - USI High Byte Shift Register"]
        pub type UsisrhR = crate::FieldReader;
        #[doc = "Field `USISRH` writer - USI High Byte Shift Register"]
        pub type UsisrhW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - USI High Byte Shift Register"]
            #[inline(always)]
            pub fn usisrh(&self) -> UsisrhR {
                UsisrhR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - USI High Byte Shift Register"]
            #[inline(always)]
            pub fn usisrh(&mut self) -> UsisrhW<'_, UsisrhSpec> {
                UsisrhW::new(self, 0)
            }
        }
        #[doc = "USI High Byte Shift Register\n\nYou can [`read`](crate::Reg::read) this register and get [`usisrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`usisrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UsisrhSpec;
        impl crate::RegisterSpec for UsisrhSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`usisrh::R`](R) reader structure"]
        impl crate::Readable for UsisrhSpec {}
        #[doc = "`write(|w| ..)` method takes [`usisrh::W`](W) writer structure"]
        impl crate::Writable for UsisrhSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets USISRH to value 0"]
        impl crate::Resettable for UsisrhSpec {}
    }
}
#[doc = "Calibration Data"]
pub type CalibrationData = crate::Periph<calibration_data::RegisterBlock, 0x10f8>;
impl core::fmt::Debug for CalibrationData {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CalibrationData").finish()
    }
}
#[doc = "Calibration Data"]
pub mod calibration_data {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        caldco_16mhz: Caldco16mhz,
        calbc1_16mhz: Calbc1_16mhz,
        caldco_12mhz: Caldco12mhz,
        calbc1_12mhz: Calbc1_12mhz,
        caldco_8mhz: Caldco8mhz,
        calbc1_8mhz: Calbc1_8mhz,
        caldco_1mhz: Caldco1mhz,
        calbc1_1mhz: Calbc1_1mhz,
    }
    impl RegisterBlock {
        #[doc = "0x00 - DCOCTL Calibration Data for 16MHz"]
        #[inline(always)]
        pub const fn caldco_16mhz(&self) -> &Caldco16mhz {
            &self.caldco_16mhz
        }
        #[doc = "0x01 - BCSCTL1 Calibration Data for 16MHz"]
        #[inline(always)]
        pub const fn calbc1_16mhz(&self) -> &Calbc1_16mhz {
            &self.calbc1_16mhz
        }
        #[doc = "0x02 - DCOCTL Calibration Data for 12MHz"]
        #[inline(always)]
        pub const fn caldco_12mhz(&self) -> &Caldco12mhz {
            &self.caldco_12mhz
        }
        #[doc = "0x03 - BCSCTL1 Calibration Data for 12MHz"]
        #[inline(always)]
        pub const fn calbc1_12mhz(&self) -> &Calbc1_12mhz {
            &self.calbc1_12mhz
        }
        #[doc = "0x04 - DCOCTL Calibration Data for 8MHz"]
        #[inline(always)]
        pub const fn caldco_8mhz(&self) -> &Caldco8mhz {
            &self.caldco_8mhz
        }
        #[doc = "0x05 - BCSCTL1 Calibration Data for 8MHz"]
        #[inline(always)]
        pub const fn calbc1_8mhz(&self) -> &Calbc1_8mhz {
            &self.calbc1_8mhz
        }
        #[doc = "0x06 - DCOCTL Calibration Data for 1MHz"]
        #[inline(always)]
        pub const fn caldco_1mhz(&self) -> &Caldco1mhz {
            &self.caldco_1mhz
        }
        #[doc = "0x07 - BCSCTL1 Calibration Data for 1MHz"]
        #[inline(always)]
        pub const fn calbc1_1mhz(&self) -> &Calbc1_1mhz {
            &self.calbc1_1mhz
        }
    }
    #[doc = "CALDCO_16MHZ (rw) register accessor: DCOCTL Calibration Data for 16MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_16mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_16mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@caldco_16mhz`] module"]
    #[doc(alias = "CALDCO_16MHZ")]
    pub type Caldco16mhz = crate::Reg<caldco_16mhz::Caldco16mhzSpec>;
    #[doc = "DCOCTL Calibration Data for 16MHz"]
    pub mod caldco_16mhz {
        #[doc = "Register `CALDCO_16MHZ` reader"]
        pub type R = crate::R<Caldco16mhzSpec>;
        #[doc = "Register `CALDCO_16MHZ` writer"]
        pub type W = crate::W<Caldco16mhzSpec>;
        #[doc = "Field `CALDCO_16MHZ` reader - Value for the DCOCTL register for 16 MHz"]
        pub type Caldco16mhzR = crate::FieldReader;
        #[doc = "Field `CALDCO_16MHZ` writer - Value for the DCOCTL register for 16 MHz"]
        pub type Caldco16mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 16 MHz"]
            #[inline(always)]
            pub fn caldco_16mhz(&self) -> Caldco16mhzR {
                Caldco16mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 16 MHz"]
            #[inline(always)]
            pub fn caldco_16mhz(&mut self) -> Caldco16mhzW<'_, Caldco16mhzSpec> {
                Caldco16mhzW::new(self, 0)
            }
        }
        #[doc = "DCOCTL Calibration Data for 16MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_16mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_16mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Caldco16mhzSpec;
        impl crate::RegisterSpec for Caldco16mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`caldco_16mhz::R`](R) reader structure"]
        impl crate::Readable for Caldco16mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`caldco_16mhz::W`](W) writer structure"]
        impl crate::Writable for Caldco16mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALDCO_16MHZ to value 0"]
        impl crate::Resettable for Caldco16mhzSpec {}
    }
    #[doc = "CALBC1_16MHZ (rw) register accessor: BCSCTL1 Calibration Data for 16MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_16mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_16mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calbc1_16mhz`] module"]
    #[doc(alias = "CALBC1_16MHZ")]
    pub type Calbc1_16mhz = crate::Reg<calbc1_16mhz::Calbc1_16mhzSpec>;
    #[doc = "BCSCTL1 Calibration Data for 16MHz"]
    pub mod calbc1_16mhz {
        #[doc = "Register `CALBC1_16MHZ` reader"]
        pub type R = crate::R<Calbc1_16mhzSpec>;
        #[doc = "Register `CALBC1_16MHZ` writer"]
        pub type W = crate::W<Calbc1_16mhzSpec>;
        #[doc = "Field `CALBC1_16MHZ` reader - Value for the BCSCTL1 register for 16 MHz"]
        pub type Calbc1_16mhzR = crate::FieldReader;
        #[doc = "Field `CALBC1_16MHZ` writer - Value for the BCSCTL1 register for 16 MHz"]
        pub type Calbc1_16mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 16 MHz"]
            #[inline(always)]
            pub fn calbc1_16mhz(&self) -> Calbc1_16mhzR {
                Calbc1_16mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 16 MHz"]
            #[inline(always)]
            pub fn calbc1_16mhz(&mut self) -> Calbc1_16mhzW<'_, Calbc1_16mhzSpec> {
                Calbc1_16mhzW::new(self, 0)
            }
        }
        #[doc = "BCSCTL1 Calibration Data for 16MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_16mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_16mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Calbc1_16mhzSpec;
        impl crate::RegisterSpec for Calbc1_16mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`calbc1_16mhz::R`](R) reader structure"]
        impl crate::Readable for Calbc1_16mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`calbc1_16mhz::W`](W) writer structure"]
        impl crate::Writable for Calbc1_16mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALBC1_16MHZ to value 0"]
        impl crate::Resettable for Calbc1_16mhzSpec {}
    }
    #[doc = "CALDCO_12MHZ (rw) register accessor: DCOCTL Calibration Data for 12MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_12mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_12mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@caldco_12mhz`] module"]
    #[doc(alias = "CALDCO_12MHZ")]
    pub type Caldco12mhz = crate::Reg<caldco_12mhz::Caldco12mhzSpec>;
    #[doc = "DCOCTL Calibration Data for 12MHz"]
    pub mod caldco_12mhz {
        #[doc = "Register `CALDCO_12MHZ` reader"]
        pub type R = crate::R<Caldco12mhzSpec>;
        #[doc = "Register `CALDCO_12MHZ` writer"]
        pub type W = crate::W<Caldco12mhzSpec>;
        #[doc = "Field `CALDCO_12MHZ` reader - Value for the DCOCTL register for 12 MHz"]
        pub type Caldco12mhzR = crate::FieldReader;
        #[doc = "Field `CALDCO_12MHZ` writer - Value for the DCOCTL register for 12 MHz"]
        pub type Caldco12mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 12 MHz"]
            #[inline(always)]
            pub fn caldco_12mhz(&self) -> Caldco12mhzR {
                Caldco12mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 12 MHz"]
            #[inline(always)]
            pub fn caldco_12mhz(&mut self) -> Caldco12mhzW<'_, Caldco12mhzSpec> {
                Caldco12mhzW::new(self, 0)
            }
        }
        #[doc = "DCOCTL Calibration Data for 12MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_12mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_12mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Caldco12mhzSpec;
        impl crate::RegisterSpec for Caldco12mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`caldco_12mhz::R`](R) reader structure"]
        impl crate::Readable for Caldco12mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`caldco_12mhz::W`](W) writer structure"]
        impl crate::Writable for Caldco12mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALDCO_12MHZ to value 0"]
        impl crate::Resettable for Caldco12mhzSpec {}
    }
    #[doc = "CALBC1_12MHZ (rw) register accessor: BCSCTL1 Calibration Data for 12MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_12mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_12mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calbc1_12mhz`] module"]
    #[doc(alias = "CALBC1_12MHZ")]
    pub type Calbc1_12mhz = crate::Reg<calbc1_12mhz::Calbc1_12mhzSpec>;
    #[doc = "BCSCTL1 Calibration Data for 12MHz"]
    pub mod calbc1_12mhz {
        #[doc = "Register `CALBC1_12MHZ` reader"]
        pub type R = crate::R<Calbc1_12mhzSpec>;
        #[doc = "Register `CALBC1_12MHZ` writer"]
        pub type W = crate::W<Calbc1_12mhzSpec>;
        #[doc = "Field `CALBC1_12MHZ` reader - Value for the BCSCTL1 register for 12 MHz"]
        pub type Calbc1_12mhzR = crate::FieldReader;
        #[doc = "Field `CALBC1_12MHZ` writer - Value for the BCSCTL1 register for 12 MHz"]
        pub type Calbc1_12mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 12 MHz"]
            #[inline(always)]
            pub fn calbc1_12mhz(&self) -> Calbc1_12mhzR {
                Calbc1_12mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 12 MHz"]
            #[inline(always)]
            pub fn calbc1_12mhz(&mut self) -> Calbc1_12mhzW<'_, Calbc1_12mhzSpec> {
                Calbc1_12mhzW::new(self, 0)
            }
        }
        #[doc = "BCSCTL1 Calibration Data for 12MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_12mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_12mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Calbc1_12mhzSpec;
        impl crate::RegisterSpec for Calbc1_12mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`calbc1_12mhz::R`](R) reader structure"]
        impl crate::Readable for Calbc1_12mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`calbc1_12mhz::W`](W) writer structure"]
        impl crate::Writable for Calbc1_12mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALBC1_12MHZ to value 0"]
        impl crate::Resettable for Calbc1_12mhzSpec {}
    }
    #[doc = "CALDCO_8MHZ (rw) register accessor: DCOCTL Calibration Data for 8MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_8mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_8mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@caldco_8mhz`] module"]
    #[doc(alias = "CALDCO_8MHZ")]
    pub type Caldco8mhz = crate::Reg<caldco_8mhz::Caldco8mhzSpec>;
    #[doc = "DCOCTL Calibration Data for 8MHz"]
    pub mod caldco_8mhz {
        #[doc = "Register `CALDCO_8MHZ` reader"]
        pub type R = crate::R<Caldco8mhzSpec>;
        #[doc = "Register `CALDCO_8MHZ` writer"]
        pub type W = crate::W<Caldco8mhzSpec>;
        #[doc = "Field `CALDCO_8MHZ` reader - Value for the DCOCTL register for 8 MHz"]
        pub type Caldco8mhzR = crate::FieldReader;
        #[doc = "Field `CALDCO_8MHZ` writer - Value for the DCOCTL register for 8 MHz"]
        pub type Caldco8mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 8 MHz"]
            #[inline(always)]
            pub fn caldco_8mhz(&self) -> Caldco8mhzR {
                Caldco8mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 8 MHz"]
            #[inline(always)]
            pub fn caldco_8mhz(&mut self) -> Caldco8mhzW<'_, Caldco8mhzSpec> {
                Caldco8mhzW::new(self, 0)
            }
        }
        #[doc = "DCOCTL Calibration Data for 8MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_8mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_8mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Caldco8mhzSpec;
        impl crate::RegisterSpec for Caldco8mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`caldco_8mhz::R`](R) reader structure"]
        impl crate::Readable for Caldco8mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`caldco_8mhz::W`](W) writer structure"]
        impl crate::Writable for Caldco8mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALDCO_8MHZ to value 0"]
        impl crate::Resettable for Caldco8mhzSpec {}
    }
    #[doc = "CALBC1_8MHZ (rw) register accessor: BCSCTL1 Calibration Data for 8MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_8mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_8mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calbc1_8mhz`] module"]
    #[doc(alias = "CALBC1_8MHZ")]
    pub type Calbc1_8mhz = crate::Reg<calbc1_8mhz::Calbc1_8mhzSpec>;
    #[doc = "BCSCTL1 Calibration Data for 8MHz"]
    pub mod calbc1_8mhz {
        #[doc = "Register `CALBC1_8MHZ` reader"]
        pub type R = crate::R<Calbc1_8mhzSpec>;
        #[doc = "Register `CALBC1_8MHZ` writer"]
        pub type W = crate::W<Calbc1_8mhzSpec>;
        #[doc = "Field `CALBC1_8MHZ` reader - Value for the BCSCTL1 register for 8 MHz"]
        pub type Calbc1_8mhzR = crate::FieldReader;
        #[doc = "Field `CALBC1_8MHZ` writer - Value for the BCSCTL1 register for 8 MHz"]
        pub type Calbc1_8mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 8 MHz"]
            #[inline(always)]
            pub fn calbc1_8mhz(&self) -> Calbc1_8mhzR {
                Calbc1_8mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 8 MHz"]
            #[inline(always)]
            pub fn calbc1_8mhz(&mut self) -> Calbc1_8mhzW<'_, Calbc1_8mhzSpec> {
                Calbc1_8mhzW::new(self, 0)
            }
        }
        #[doc = "BCSCTL1 Calibration Data for 8MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_8mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_8mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Calbc1_8mhzSpec;
        impl crate::RegisterSpec for Calbc1_8mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`calbc1_8mhz::R`](R) reader structure"]
        impl crate::Readable for Calbc1_8mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`calbc1_8mhz::W`](W) writer structure"]
        impl crate::Writable for Calbc1_8mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALBC1_8MHZ to value 0"]
        impl crate::Resettable for Calbc1_8mhzSpec {}
    }
    #[doc = "CALDCO_1MHZ (rw) register accessor: DCOCTL Calibration Data for 1MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_1mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_1mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@caldco_1mhz`] module"]
    #[doc(alias = "CALDCO_1MHZ")]
    pub type Caldco1mhz = crate::Reg<caldco_1mhz::Caldco1mhzSpec>;
    #[doc = "DCOCTL Calibration Data for 1MHz"]
    pub mod caldco_1mhz {
        #[doc = "Register `CALDCO_1MHZ` reader"]
        pub type R = crate::R<Caldco1mhzSpec>;
        #[doc = "Register `CALDCO_1MHZ` writer"]
        pub type W = crate::W<Caldco1mhzSpec>;
        #[doc = "Field `CALDCO_1MHZ` reader - Value for the DCOCTL register for 1 MHz"]
        pub type Caldco1mhzR = crate::FieldReader;
        #[doc = "Field `CALDCO_1MHZ` writer - Value for the DCOCTL register for 1 MHz"]
        pub type Caldco1mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 1 MHz"]
            #[inline(always)]
            pub fn caldco_1mhz(&self) -> Caldco1mhzR {
                Caldco1mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the DCOCTL register for 1 MHz"]
            #[inline(always)]
            pub fn caldco_1mhz(&mut self) -> Caldco1mhzW<'_, Caldco1mhzSpec> {
                Caldco1mhzW::new(self, 0)
            }
        }
        #[doc = "DCOCTL Calibration Data for 1MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`caldco_1mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`caldco_1mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Caldco1mhzSpec;
        impl crate::RegisterSpec for Caldco1mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`caldco_1mhz::R`](R) reader structure"]
        impl crate::Readable for Caldco1mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`caldco_1mhz::W`](W) writer structure"]
        impl crate::Writable for Caldco1mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALDCO_1MHZ to value 0"]
        impl crate::Resettable for Caldco1mhzSpec {}
    }
    #[doc = "CALBC1_1MHZ (rw) register accessor: BCSCTL1 Calibration Data for 1MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_1mhz::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_1mhz::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@calbc1_1mhz`] module"]
    #[doc(alias = "CALBC1_1MHZ")]
    pub type Calbc1_1mhz = crate::Reg<calbc1_1mhz::Calbc1_1mhzSpec>;
    #[doc = "BCSCTL1 Calibration Data for 1MHz"]
    pub mod calbc1_1mhz {
        #[doc = "Register `CALBC1_1MHZ` reader"]
        pub type R = crate::R<Calbc1_1mhzSpec>;
        #[doc = "Register `CALBC1_1MHZ` writer"]
        pub type W = crate::W<Calbc1_1mhzSpec>;
        #[doc = "Field `CALBC1_1MHZ` reader - Value for the BCSCTL1 register for 1 MHz"]
        pub type Calbc1_1mhzR = crate::FieldReader;
        #[doc = "Field `CALBC1_1MHZ` writer - Value for the BCSCTL1 register for 1 MHz"]
        pub type Calbc1_1mhzW<'a, REG> = crate::FieldWriter<'a, REG, 8, u8, crate::Safe>;
        impl R {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 1 MHz"]
            #[inline(always)]
            pub fn calbc1_1mhz(&self) -> Calbc1_1mhzR {
                Calbc1_1mhzR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Value for the BCSCTL1 register for 1 MHz"]
            #[inline(always)]
            pub fn calbc1_1mhz(&mut self) -> Calbc1_1mhzW<'_, Calbc1_1mhzSpec> {
                Calbc1_1mhzW::new(self, 0)
            }
        }
        #[doc = "BCSCTL1 Calibration Data for 1MHz\n\nYou can [`read`](crate::Reg::read) this register and get [`calbc1_1mhz::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`calbc1_1mhz::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Calbc1_1mhzSpec;
        impl crate::RegisterSpec for Calbc1_1mhzSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`calbc1_1mhz::R`](R) reader structure"]
        impl crate::Readable for Calbc1_1mhzSpec {}
        #[doc = "`write(|w| ..)` method takes [`calbc1_1mhz::W`](W) writer structure"]
        impl crate::Writable for Calbc1_1mhzSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets CALBC1_1MHZ to value 0"]
        impl crate::Resettable for Calbc1_1mhzSpec {}
    }
}
#[doc = "Watchdog Timer"]
pub type WatchdogTimer = crate::Periph<watchdog_timer::RegisterBlock, 0x0120>;
impl core::fmt::Debug for WatchdogTimer {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WatchdogTimer").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod watchdog_timer {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        wdtctl: Wdtctl,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Watchdog Timer Control"]
        #[inline(always)]
        pub const fn wdtctl(&self) -> &Wdtctl {
            &self.wdtctl
        }
    }
    #[doc = "WDTCTL (rw) register accessor: Watchdog Timer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`wdtctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdtctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdtctl`] module"]
    #[doc(alias = "WDTCTL")]
    pub type Wdtctl = crate::Reg<wdtctl::WdtctlSpec>;
    #[doc = "Watchdog Timer Control"]
    pub mod wdtctl {
        #[doc = "Register `WDTCTL` reader"]
        pub type R = crate::R<WdtctlSpec>;
        #[doc = "Register `WDTCTL` writer"]
        pub type W = crate::W<WdtctlSpec>;
        #[doc = "Field `WDTIS0` reader - WDTIS0"]
        pub type Wdtis0R = crate::BitReader;
        #[doc = "Field `WDTIS0` writer - WDTIS0"]
        pub type Wdtis0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTIS1` reader - WDTIS1"]
        pub type Wdtis1R = crate::BitReader;
        #[doc = "Field `WDTIS1` writer - WDTIS1"]
        pub type Wdtis1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTSSEL` reader - WDTSSEL"]
        pub type WdtsselR = crate::BitReader;
        #[doc = "Field `WDTSSEL` writer - WDTSSEL"]
        pub type WdtsselW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTCNTCL` reader - WDTCNTCL"]
        pub type WdtcntclR = crate::BitReader;
        #[doc = "Field `WDTCNTCL` writer - WDTCNTCL"]
        pub type WdtcntclW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTTMSEL` reader - WDTTMSEL"]
        pub type WdttmselR = crate::BitReader;
        #[doc = "Field `WDTTMSEL` writer - WDTTMSEL"]
        pub type WdttmselW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTNMI` reader - WDTNMI"]
        pub type WdtnmiR = crate::BitReader;
        #[doc = "Field `WDTNMI` writer - WDTNMI"]
        pub type WdtnmiW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTNMIES` reader - WDTNMIES"]
        pub type WdtnmiesR = crate::BitReader;
        #[doc = "Field `WDTNMIES` writer - WDTNMIES"]
        pub type WdtnmiesW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDTHOLD` reader - WDTHOLD"]
        pub type WdtholdR = crate::BitReader;
        #[doc = "Field `WDTHOLD` writer - WDTHOLD"]
        pub type WdtholdW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - WDTIS0"]
            #[inline(always)]
            pub fn wdtis0(&self) -> Wdtis0R {
                Wdtis0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WDTIS1"]
            #[inline(always)]
            pub fn wdtis1(&self) -> Wdtis1R {
                Wdtis1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WDTSSEL"]
            #[inline(always)]
            pub fn wdtssel(&self) -> WdtsselR {
                WdtsselR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - WDTCNTCL"]
            #[inline(always)]
            pub fn wdtcntcl(&self) -> WdtcntclR {
                WdtcntclR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - WDTTMSEL"]
            #[inline(always)]
            pub fn wdttmsel(&self) -> WdttmselR {
                WdttmselR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - WDTNMI"]
            #[inline(always)]
            pub fn wdtnmi(&self) -> WdtnmiR {
                WdtnmiR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - WDTNMIES"]
            #[inline(always)]
            pub fn wdtnmies(&self) -> WdtnmiesR {
                WdtnmiesR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - WDTHOLD"]
            #[inline(always)]
            pub fn wdthold(&self) -> WdtholdR {
                WdtholdR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - WDTIS0"]
            #[inline(always)]
            pub fn wdtis0(&mut self) -> Wdtis0W<'_, WdtctlSpec> {
                Wdtis0W::new(self, 0)
            }
            #[doc = "Bit 1 - WDTIS1"]
            #[inline(always)]
            pub fn wdtis1(&mut self) -> Wdtis1W<'_, WdtctlSpec> {
                Wdtis1W::new(self, 1)
            }
            #[doc = "Bit 2 - WDTSSEL"]
            #[inline(always)]
            pub fn wdtssel(&mut self) -> WdtsselW<'_, WdtctlSpec> {
                WdtsselW::new(self, 2)
            }
            #[doc = "Bit 3 - WDTCNTCL"]
            #[inline(always)]
            pub fn wdtcntcl(&mut self) -> WdtcntclW<'_, WdtctlSpec> {
                WdtcntclW::new(self, 3)
            }
            #[doc = "Bit 4 - WDTTMSEL"]
            #[inline(always)]
            pub fn wdttmsel(&mut self) -> WdttmselW<'_, WdtctlSpec> {
                WdttmselW::new(self, 4)
            }
            #[doc = "Bit 5 - WDTNMI"]
            #[inline(always)]
            pub fn wdtnmi(&mut self) -> WdtnmiW<'_, WdtctlSpec> {
                WdtnmiW::new(self, 5)
            }
            #[doc = "Bit 6 - WDTNMIES"]
            #[inline(always)]
            pub fn wdtnmies(&mut self) -> WdtnmiesW<'_, WdtctlSpec> {
                WdtnmiesW::new(self, 6)
            }
            #[doc = "Bit 7 - WDTHOLD"]
            #[inline(always)]
            pub fn wdthold(&mut self) -> WdtholdW<'_, WdtctlSpec> {
                WdtholdW::new(self, 7)
            }
        }
        #[doc = "Watchdog Timer Control\n\nYou can [`read`](crate::Reg::read) this register and get [`wdtctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdtctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WdtctlSpec;
        impl crate::RegisterSpec for WdtctlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`wdtctl::R`](R) reader structure"]
        impl crate::Readable for WdtctlSpec {}
        #[doc = "`write(|w| ..)` method takes [`wdtctl::W`](W) writer structure"]
        impl crate::Writable for WdtctlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets WDTCTL to value 0"]
        impl crate::Resettable for WdtctlSpec {}
    }
}
#[doc = "Flash"]
pub type Flash = crate::Periph<flash::RegisterBlock, 0x0128>;
impl core::fmt::Debug for Flash {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flash").finish()
    }
}
#[doc = "Flash"]
pub mod flash {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        fctl1: Fctl1,
        fctl2: Fctl2,
        fctl3: Fctl3,
    }
    impl RegisterBlock {
        #[doc = "0x00 - FLASH Control 1"]
        #[inline(always)]
        pub const fn fctl1(&self) -> &Fctl1 {
            &self.fctl1
        }
        #[doc = "0x02 - FLASH Control 2"]
        #[inline(always)]
        pub const fn fctl2(&self) -> &Fctl2 {
            &self.fctl2
        }
        #[doc = "0x04 - FLASH Control 3"]
        #[inline(always)]
        pub const fn fctl3(&self) -> &Fctl3 {
            &self.fctl3
        }
    }
    #[doc = "FCTL1 (rw) register accessor: FLASH Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fctl1`] module"]
    #[doc(alias = "FCTL1")]
    pub type Fctl1 = crate::Reg<fctl1::Fctl1Spec>;
    #[doc = "FLASH Control 1"]
    pub mod fctl1 {
        #[doc = "Register `FCTL1` reader"]
        pub type R = crate::R<Fctl1Spec>;
        #[doc = "Register `FCTL1` writer"]
        pub type W = crate::W<Fctl1Spec>;
        #[doc = "Field `ERASE` reader - Enable bit for Flash segment erase"]
        pub type EraseR = crate::BitReader;
        #[doc = "Field `ERASE` writer - Enable bit for Flash segment erase"]
        pub type EraseW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MERAS` reader - Enable bit for Flash mass erase"]
        pub type MerasR = crate::BitReader;
        #[doc = "Field `MERAS` writer - Enable bit for Flash mass erase"]
        pub type MerasW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WRT` reader - Enable bit for Flash write"]
        pub type WrtR = crate::BitReader;
        #[doc = "Field `WRT` writer - Enable bit for Flash write"]
        pub type WrtW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BLKWRT` reader - Enable bit for Flash segment write"]
        pub type BlkwrtR = crate::BitReader;
        #[doc = "Field `BLKWRT` writer - Enable bit for Flash segment write"]
        pub type BlkwrtW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - Enable bit for Flash segment erase"]
            #[inline(always)]
            pub fn erase(&self) -> EraseR {
                EraseR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable bit for Flash mass erase"]
            #[inline(always)]
            pub fn meras(&self) -> MerasR {
                MerasR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 6 - Enable bit for Flash write"]
            #[inline(always)]
            pub fn wrt(&self) -> WrtR {
                WrtR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Enable bit for Flash segment write"]
            #[inline(always)]
            pub fn blkwrt(&self) -> BlkwrtR {
                BlkwrtR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - Enable bit for Flash segment erase"]
            #[inline(always)]
            pub fn erase(&mut self) -> EraseW<'_, Fctl1Spec> {
                EraseW::new(self, 1)
            }
            #[doc = "Bit 2 - Enable bit for Flash mass erase"]
            #[inline(always)]
            pub fn meras(&mut self) -> MerasW<'_, Fctl1Spec> {
                MerasW::new(self, 2)
            }
            #[doc = "Bit 6 - Enable bit for Flash write"]
            #[inline(always)]
            pub fn wrt(&mut self) -> WrtW<'_, Fctl1Spec> {
                WrtW::new(self, 6)
            }
            #[doc = "Bit 7 - Enable bit for Flash segment write"]
            #[inline(always)]
            pub fn blkwrt(&mut self) -> BlkwrtW<'_, Fctl1Spec> {
                BlkwrtW::new(self, 7)
            }
        }
        #[doc = "FLASH Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fctl1Spec;
        impl crate::RegisterSpec for Fctl1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`fctl1::R`](R) reader structure"]
        impl crate::Readable for Fctl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`fctl1::W`](W) writer structure"]
        impl crate::Writable for Fctl1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCTL1 to value 0"]
        impl crate::Resettable for Fctl1Spec {}
    }
    #[doc = "FCTL2 (rw) register accessor: FLASH Control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fctl2`] module"]
    #[doc(alias = "FCTL2")]
    pub type Fctl2 = crate::Reg<fctl2::Fctl2Spec>;
    #[doc = "FLASH Control 2"]
    pub mod fctl2 {
        #[doc = "Register `FCTL2` reader"]
        pub type R = crate::R<Fctl2Spec>;
        #[doc = "Register `FCTL2` writer"]
        pub type W = crate::W<Fctl2Spec>;
        #[doc = "Field `FN0` reader - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
        pub type Fn0R = crate::BitReader;
        #[doc = "Field `FN0` writer - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
        pub type Fn0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FN1` reader - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
        pub type Fn1R = crate::BitReader;
        #[doc = "Field `FN1` writer - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
        pub type Fn1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FN2` reader - FN2"]
        pub type Fn2R = crate::BitReader;
        #[doc = "Field `FN2` writer - FN2"]
        pub type Fn2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FN3` reader - FN3"]
        pub type Fn3R = crate::BitReader;
        #[doc = "Field `FN3` writer - FN3"]
        pub type Fn3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FN4` reader - FN4"]
        pub type Fn4R = crate::BitReader;
        #[doc = "Field `FN4` writer - FN4"]
        pub type Fn4W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FN5` reader - FN5"]
        pub type Fn5R = crate::BitReader;
        #[doc = "Field `FN5` writer - FN5"]
        pub type Fn5W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Flash clock select 0 */ /* to distinguish from USART SSELx\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Fssel {
            #[doc = "0: Flash clock select: 0 - ACLK"]
            Fssel0 = 0,
            #[doc = "1: Flash clock select: 1 - MCLK"]
            Fssel1 = 1,
            #[doc = "2: Flash clock select: 2 - SMCLK"]
            Fssel2 = 2,
            #[doc = "3: Flash clock select: 3 - SMCLK"]
            Fssel3 = 3,
        }
        impl From<Fssel> for u8 {
            #[inline(always)]
            fn from(variant: Fssel) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Fssel {
            type Ux = u8;
        }
        impl crate::IsEnum for Fssel {}
        #[doc = "Field `FSSEL` reader - Flash clock select 0 */ /* to distinguish from USART SSELx"]
        pub type FsselR = crate::FieldReader<Fssel>;
        impl FsselR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Fssel {
                match self.bits {
                    0 => Fssel::Fssel0,
                    1 => Fssel::Fssel1,
                    2 => Fssel::Fssel2,
                    3 => Fssel::Fssel3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Flash clock select: 0 - ACLK"]
            #[inline(always)]
            pub fn is_fssel_0(&self) -> bool {
                *self == Fssel::Fssel0
            }
            #[doc = "Flash clock select: 1 - MCLK"]
            #[inline(always)]
            pub fn is_fssel_1(&self) -> bool {
                *self == Fssel::Fssel1
            }
            #[doc = "Flash clock select: 2 - SMCLK"]
            #[inline(always)]
            pub fn is_fssel_2(&self) -> bool {
                *self == Fssel::Fssel2
            }
            #[doc = "Flash clock select: 3 - SMCLK"]
            #[inline(always)]
            pub fn is_fssel_3(&self) -> bool {
                *self == Fssel::Fssel3
            }
        }
        #[doc = "Field `FSSEL` writer - Flash clock select 0 */ /* to distinguish from USART SSELx"]
        pub type FsselW<'a, REG> = crate::FieldWriter<'a, REG, 2, Fssel, crate::Safe>;
        impl<'a, REG> FsselW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Flash clock select: 0 - ACLK"]
            #[inline(always)]
            pub fn fssel_0(self) -> &'a mut crate::W<REG> {
                self.variant(Fssel::Fssel0)
            }
            #[doc = "Flash clock select: 1 - MCLK"]
            #[inline(always)]
            pub fn fssel_1(self) -> &'a mut crate::W<REG> {
                self.variant(Fssel::Fssel1)
            }
            #[doc = "Flash clock select: 2 - SMCLK"]
            #[inline(always)]
            pub fn fssel_2(self) -> &'a mut crate::W<REG> {
                self.variant(Fssel::Fssel2)
            }
            #[doc = "Flash clock select: 3 - SMCLK"]
            #[inline(always)]
            pub fn fssel_3(self) -> &'a mut crate::W<REG> {
                self.variant(Fssel::Fssel3)
            }
        }
        impl R {
            #[doc = "Bit 0 - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
            #[inline(always)]
            pub fn fn0(&self) -> Fn0R {
                Fn0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
            #[inline(always)]
            pub fn fn1(&self) -> Fn1R {
                Fn1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - FN2"]
            #[inline(always)]
            pub fn fn2(&self) -> Fn2R {
                Fn2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - FN3"]
            #[inline(always)]
            pub fn fn3(&self) -> Fn3R {
                Fn3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - FN4"]
            #[inline(always)]
            pub fn fn4(&self) -> Fn4R {
                Fn4R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - FN5"]
            #[inline(always)]
            pub fn fn5(&self) -> Fn5R {
                Fn5R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bits 6:7 - Flash clock select 0 */ /* to distinguish from USART SSELx"]
            #[inline(always)]
            pub fn fssel(&self) -> FsselR {
                FsselR::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Divide Flash clock by 1 to 64 using FN0 to FN5 according to:"]
            #[inline(always)]
            pub fn fn0(&mut self) -> Fn0W<'_, Fctl2Spec> {
                Fn0W::new(self, 0)
            }
            #[doc = "Bit 1 - 32*FN5 + 16*FN4 + 8*FN3 + 4*FN2 + 2*FN1 + FN0 + 1"]
            #[inline(always)]
            pub fn fn1(&mut self) -> Fn1W<'_, Fctl2Spec> {
                Fn1W::new(self, 1)
            }
            #[doc = "Bit 2 - FN2"]
            #[inline(always)]
            pub fn fn2(&mut self) -> Fn2W<'_, Fctl2Spec> {
                Fn2W::new(self, 2)
            }
            #[doc = "Bit 3 - FN3"]
            #[inline(always)]
            pub fn fn3(&mut self) -> Fn3W<'_, Fctl2Spec> {
                Fn3W::new(self, 3)
            }
            #[doc = "Bit 4 - FN4"]
            #[inline(always)]
            pub fn fn4(&mut self) -> Fn4W<'_, Fctl2Spec> {
                Fn4W::new(self, 4)
            }
            #[doc = "Bit 5 - FN5"]
            #[inline(always)]
            pub fn fn5(&mut self) -> Fn5W<'_, Fctl2Spec> {
                Fn5W::new(self, 5)
            }
            #[doc = "Bits 6:7 - Flash clock select 0 */ /* to distinguish from USART SSELx"]
            #[inline(always)]
            pub fn fssel(&mut self) -> FsselW<'_, Fctl2Spec> {
                FsselW::new(self, 6)
            }
        }
        #[doc = "FLASH Control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fctl2Spec;
        impl crate::RegisterSpec for Fctl2Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`fctl2::R`](R) reader structure"]
        impl crate::Readable for Fctl2Spec {}
        #[doc = "`write(|w| ..)` method takes [`fctl2::W`](W) writer structure"]
        impl crate::Writable for Fctl2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCTL2 to value 0"]
        impl crate::Resettable for Fctl2Spec {}
    }
    #[doc = "FCTL3 (rw) register accessor: FLASH Control 3\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fctl3`] module"]
    #[doc(alias = "FCTL3")]
    pub type Fctl3 = crate::Reg<fctl3::Fctl3Spec>;
    #[doc = "FLASH Control 3"]
    pub mod fctl3 {
        #[doc = "Register `FCTL3` reader"]
        pub type R = crate::R<Fctl3Spec>;
        #[doc = "Register `FCTL3` writer"]
        pub type W = crate::W<Fctl3Spec>;
        #[doc = "Field `BUSY` reader - Flash busy: 1"]
        pub type BusyR = crate::BitReader;
        #[doc = "Field `BUSY` writer - Flash busy: 1"]
        pub type BusyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `KEYV` reader - Flash Key violation flag"]
        pub type KeyvR = crate::BitReader;
        #[doc = "Field `KEYV` writer - Flash Key violation flag"]
        pub type KeyvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ACCVIFG` reader - Flash Access violation flag"]
        pub type AccvifgR = crate::BitReader;
        #[doc = "Field `ACCVIFG` writer - Flash Access violation flag"]
        pub type AccvifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WAIT` reader - Wait flag for segment write"]
        pub type WaitR = crate::BitReader;
        #[doc = "Field `WAIT` writer - Wait flag for segment write"]
        pub type WaitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LOCK` reader - Lock bit: 1 - Flash is locked (read only)"]
        pub type LockR = crate::BitReader;
        #[doc = "Field `LOCK` writer - Lock bit: 1 - Flash is locked (read only)"]
        pub type LockW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EMEX` reader - Flash Emergency Exit"]
        pub type EmexR = crate::BitReader;
        #[doc = "Field `EMEX` writer - Flash Emergency Exit"]
        pub type EmexW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LOCKA` reader - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
        pub type LockaR = crate::BitReader;
        #[doc = "Field `LOCKA` writer - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
        pub type LockaW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FAIL` reader - Last Program or Erase failed"]
        pub type FailR = crate::BitReader;
        #[doc = "Field `FAIL` writer - Last Program or Erase failed"]
        pub type FailW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Flash busy: 1"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Flash Key violation flag"]
            #[inline(always)]
            pub fn keyv(&self) -> KeyvR {
                KeyvR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Flash Access violation flag"]
            #[inline(always)]
            pub fn accvifg(&self) -> AccvifgR {
                AccvifgR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Wait flag for segment write"]
            #[inline(always)]
            pub fn wait(&self) -> WaitR {
                WaitR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)"]
            #[inline(always)]
            pub fn lock(&self) -> LockR {
                LockR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Flash Emergency Exit"]
            #[inline(always)]
            pub fn emex(&self) -> EmexR {
                EmexR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
            #[inline(always)]
            pub fn locka(&self) -> LockaR {
                LockaR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Last Program or Erase failed"]
            #[inline(always)]
            pub fn fail(&self) -> FailR {
                FailR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Flash busy: 1"]
            #[inline(always)]
            pub fn busy(&mut self) -> BusyW<'_, Fctl3Spec> {
                BusyW::new(self, 0)
            }
            #[doc = "Bit 1 - Flash Key violation flag"]
            #[inline(always)]
            pub fn keyv(&mut self) -> KeyvW<'_, Fctl3Spec> {
                KeyvW::new(self, 1)
            }
            #[doc = "Bit 2 - Flash Access violation flag"]
            #[inline(always)]
            pub fn accvifg(&mut self) -> AccvifgW<'_, Fctl3Spec> {
                AccvifgW::new(self, 2)
            }
            #[doc = "Bit 3 - Wait flag for segment write"]
            #[inline(always)]
            pub fn wait(&mut self) -> WaitW<'_, Fctl3Spec> {
                WaitW::new(self, 3)
            }
            #[doc = "Bit 4 - Lock bit: 1 - Flash is locked (read only)"]
            #[inline(always)]
            pub fn lock(&mut self) -> LockW<'_, Fctl3Spec> {
                LockW::new(self, 4)
            }
            #[doc = "Bit 5 - Flash Emergency Exit"]
            #[inline(always)]
            pub fn emex(&mut self) -> EmexW<'_, Fctl3Spec> {
                EmexW::new(self, 5)
            }
            #[doc = "Bit 6 - Segment A Lock bit: read = 1 - Segment is locked (read only)"]
            #[inline(always)]
            pub fn locka(&mut self) -> LockaW<'_, Fctl3Spec> {
                LockaW::new(self, 6)
            }
            #[doc = "Bit 7 - Last Program or Erase failed"]
            #[inline(always)]
            pub fn fail(&mut self) -> FailW<'_, Fctl3Spec> {
                FailW::new(self, 7)
            }
        }
        #[doc = "FLASH Control 3\n\nYou can [`read`](crate::Reg::read) this register and get [`fctl3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fctl3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fctl3Spec;
        impl crate::RegisterSpec for Fctl3Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`fctl3::R`](R) reader structure"]
        impl crate::Readable for Fctl3Spec {}
        #[doc = "`write(|w| ..)` method takes [`fctl3::W`](W) writer structure"]
        impl crate::Writable for Fctl3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCTL3 to value 0"]
        impl crate::Resettable for Fctl3Spec {}
    }
}
#[doc = "Timer A2"]
pub type TimerA2 = crate::Periph<timer_a2::RegisterBlock, 0x012e>;
impl core::fmt::Debug for TimerA2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TimerA2").finish()
    }
}
#[doc = "Timer A2"]
pub mod timer_a2 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        taiv: Taiv,
        _reserved1: [u8; 0x30],
        tactl: Tactl,
        tacctl0: Tacctl0,
        tacctl1: Tacctl1,
        _reserved4: [u8; 0x0a],
        tar: Tar,
        taccr0: Taccr0,
        taccr1: Taccr1,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Timer A Interrupt Vector Word"]
        #[inline(always)]
        pub const fn taiv(&self) -> &Taiv {
            &self.taiv
        }
        #[doc = "0x32 - Timer A Control"]
        #[inline(always)]
        pub const fn tactl(&self) -> &Tactl {
            &self.tactl
        }
        #[doc = "0x34 - Timer A Capture/Compare Control 0"]
        #[inline(always)]
        pub const fn tacctl0(&self) -> &Tacctl0 {
            &self.tacctl0
        }
        #[doc = "0x36 - Timer A Capture/Compare Control 1"]
        #[inline(always)]
        pub const fn tacctl1(&self) -> &Tacctl1 {
            &self.tacctl1
        }
        #[doc = "0x42 - Timer A Counter Register"]
        #[inline(always)]
        pub const fn tar(&self) -> &Tar {
            &self.tar
        }
        #[doc = "0x44 - Timer A Capture/Compare 0"]
        #[inline(always)]
        pub const fn taccr0(&self) -> &Taccr0 {
            &self.taccr0
        }
        #[doc = "0x46 - Timer A Capture/Compare 1"]
        #[inline(always)]
        pub const fn taccr1(&self) -> &Taccr1 {
            &self.taccr1
        }
    }
    #[doc = "TAIV (rw) register accessor: Timer A Interrupt Vector Word\n\nYou can [`read`](crate::Reg::read) this register and get [`taiv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taiv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@taiv`] module"]
    #[doc(alias = "TAIV")]
    pub type Taiv = crate::Reg<taiv::TaivSpec>;
    #[doc = "Timer A Interrupt Vector Word"]
    pub mod taiv {
        #[doc = "Register `TAIV` reader"]
        pub type R = crate::R<TaivSpec>;
        #[doc = "Register `TAIV` writer"]
        pub type W = crate::W<TaivSpec>;
        #[doc = "Field `TAIV` reader - Timer A Interrupt Vector Word"]
        pub type TaivR = crate::FieldReader<u16>;
        #[doc = "Field `TAIV` writer - Timer A Interrupt Vector Word"]
        pub type TaivW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Timer A Interrupt Vector Word"]
            #[inline(always)]
            pub fn taiv(&self) -> TaivR {
                TaivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer A Interrupt Vector Word"]
            #[inline(always)]
            pub fn taiv(&mut self) -> TaivW<'_, TaivSpec> {
                TaivW::new(self, 0)
            }
        }
        #[doc = "Timer A Interrupt Vector Word\n\nYou can [`read`](crate::Reg::read) this register and get [`taiv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taiv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TaivSpec;
        impl crate::RegisterSpec for TaivSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`taiv::R`](R) reader structure"]
        impl crate::Readable for TaivSpec {}
        #[doc = "`write(|w| ..)` method takes [`taiv::W`](W) writer structure"]
        impl crate::Writable for TaivSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets TAIV to value 0"]
        impl crate::Resettable for TaivSpec {}
    }
    #[doc = "TACTL (rw) register accessor: Timer A Control\n\nYou can [`read`](crate::Reg::read) this register and get [`tactl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tactl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tactl`] module"]
    #[doc(alias = "TACTL")]
    pub type Tactl = crate::Reg<tactl::TactlSpec>;
    #[doc = "Timer A Control"]
    pub mod tactl {
        #[doc = "Register `TACTL` reader"]
        pub type R = crate::R<TactlSpec>;
        #[doc = "Register `TACTL` writer"]
        pub type W = crate::W<TactlSpec>;
        #[doc = "Field `TAIFG` reader - Timer A counter interrupt flag"]
        pub type TaifgR = crate::BitReader;
        #[doc = "Field `TAIFG` writer - Timer A counter interrupt flag"]
        pub type TaifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TAIE` reader - Timer A counter interrupt enable"]
        pub type TaieR = crate::BitReader;
        #[doc = "Field `TAIE` writer - Timer A counter interrupt enable"]
        pub type TaieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TACLR` reader - Timer A counter clear"]
        pub type TaclrR = crate::BitReader;
        #[doc = "Field `TACLR` writer - Timer A counter clear"]
        pub type TaclrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Timer A mode control 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Mc {
            #[doc = "0: Timer A mode control: 0 - Stop"]
            Mc0 = 0,
            #[doc = "1: Timer A mode control: 1 - Up to CCR0"]
            Mc1 = 1,
            #[doc = "2: Timer A mode control: 2 - Continous up"]
            Mc2 = 2,
            #[doc = "3: Timer A mode control: 3 - Up/Down"]
            Mc3 = 3,
        }
        impl From<Mc> for u8 {
            #[inline(always)]
            fn from(variant: Mc) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Mc {
            type Ux = u8;
        }
        impl crate::IsEnum for Mc {}
        #[doc = "Field `MC` reader - Timer A mode control 1"]
        pub type McR = crate::FieldReader<Mc>;
        impl McR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Mc {
                match self.bits {
                    0 => Mc::Mc0,
                    1 => Mc::Mc1,
                    2 => Mc::Mc2,
                    3 => Mc::Mc3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Timer A mode control: 0 - Stop"]
            #[inline(always)]
            pub fn is_mc_0(&self) -> bool {
                *self == Mc::Mc0
            }
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            #[inline(always)]
            pub fn is_mc_1(&self) -> bool {
                *self == Mc::Mc1
            }
            #[doc = "Timer A mode control: 2 - Continous up"]
            #[inline(always)]
            pub fn is_mc_2(&self) -> bool {
                *self == Mc::Mc2
            }
            #[doc = "Timer A mode control: 3 - Up/Down"]
            #[inline(always)]
            pub fn is_mc_3(&self) -> bool {
                *self == Mc::Mc3
            }
        }
        #[doc = "Field `MC` writer - Timer A mode control 1"]
        pub type McW<'a, REG> = crate::FieldWriter<'a, REG, 2, Mc, crate::Safe>;
        impl<'a, REG> McW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Timer A mode control: 0 - Stop"]
            #[inline(always)]
            pub fn mc_0(self) -> &'a mut crate::W<REG> {
                self.variant(Mc::Mc0)
            }
            #[doc = "Timer A mode control: 1 - Up to CCR0"]
            #[inline(always)]
            pub fn mc_1(self) -> &'a mut crate::W<REG> {
                self.variant(Mc::Mc1)
            }
            #[doc = "Timer A mode control: 2 - Continous up"]
            #[inline(always)]
            pub fn mc_2(self) -> &'a mut crate::W<REG> {
                self.variant(Mc::Mc2)
            }
            #[doc = "Timer A mode control: 3 - Up/Down"]
            #[inline(always)]
            pub fn mc_3(self) -> &'a mut crate::W<REG> {
                self.variant(Mc::Mc3)
            }
        }
        #[doc = "Timer A clock input divider 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Id {
            #[doc = "0: Timer A input divider: 0 - /1"]
            Id0 = 0,
            #[doc = "1: Timer A input divider: 1 - /2"]
            Id1 = 1,
            #[doc = "2: Timer A input divider: 2 - /4"]
            Id2 = 2,
            #[doc = "3: Timer A input divider: 3 - /8"]
            Id3 = 3,
        }
        impl From<Id> for u8 {
            #[inline(always)]
            fn from(variant: Id) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Id {
            type Ux = u8;
        }
        impl crate::IsEnum for Id {}
        #[doc = "Field `ID` reader - Timer A clock input divider 1"]
        pub type IdR = crate::FieldReader<Id>;
        impl IdR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Id {
                match self.bits {
                    0 => Id::Id0,
                    1 => Id::Id1,
                    2 => Id::Id2,
                    3 => Id::Id3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Timer A input divider: 0 - /1"]
            #[inline(always)]
            pub fn is_id_0(&self) -> bool {
                *self == Id::Id0
            }
            #[doc = "Timer A input divider: 1 - /2"]
            #[inline(always)]
            pub fn is_id_1(&self) -> bool {
                *self == Id::Id1
            }
            #[doc = "Timer A input divider: 2 - /4"]
            #[inline(always)]
            pub fn is_id_2(&self) -> bool {
                *self == Id::Id2
            }
            #[doc = "Timer A input divider: 3 - /8"]
            #[inline(always)]
            pub fn is_id_3(&self) -> bool {
                *self == Id::Id3
            }
        }
        #[doc = "Field `ID` writer - Timer A clock input divider 1"]
        pub type IdW<'a, REG> = crate::FieldWriter<'a, REG, 2, Id, crate::Safe>;
        impl<'a, REG> IdW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Timer A input divider: 0 - /1"]
            #[inline(always)]
            pub fn id_0(self) -> &'a mut crate::W<REG> {
                self.variant(Id::Id0)
            }
            #[doc = "Timer A input divider: 1 - /2"]
            #[inline(always)]
            pub fn id_1(self) -> &'a mut crate::W<REG> {
                self.variant(Id::Id1)
            }
            #[doc = "Timer A input divider: 2 - /4"]
            #[inline(always)]
            pub fn id_2(self) -> &'a mut crate::W<REG> {
                self.variant(Id::Id2)
            }
            #[doc = "Timer A input divider: 3 - /8"]
            #[inline(always)]
            pub fn id_3(self) -> &'a mut crate::W<REG> {
                self.variant(Id::Id3)
            }
        }
        #[doc = "Timer A clock source select 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Tassel {
            #[doc = "0: Timer A clock source select: 0 - TACLK"]
            Tassel0 = 0,
            #[doc = "1: Timer A clock source select: 1 - ACLK"]
            Tassel1 = 1,
            #[doc = "2: Timer A clock source select: 2 - SMCLK"]
            Tassel2 = 2,
            #[doc = "3: Timer A clock source select: 3 - INCLK"]
            Tassel3 = 3,
        }
        impl From<Tassel> for u8 {
            #[inline(always)]
            fn from(variant: Tassel) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Tassel {
            type Ux = u8;
        }
        impl crate::IsEnum for Tassel {}
        #[doc = "Field `TASSEL` reader - Timer A clock source select 1"]
        pub type TasselR = crate::FieldReader<Tassel>;
        impl TasselR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Tassel {
                match self.bits {
                    0 => Tassel::Tassel0,
                    1 => Tassel::Tassel1,
                    2 => Tassel::Tassel2,
                    3 => Tassel::Tassel3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Timer A clock source select: 0 - TACLK"]
            #[inline(always)]
            pub fn is_tassel_0(&self) -> bool {
                *self == Tassel::Tassel0
            }
            #[doc = "Timer A clock source select: 1 - ACLK"]
            #[inline(always)]
            pub fn is_tassel_1(&self) -> bool {
                *self == Tassel::Tassel1
            }
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            #[inline(always)]
            pub fn is_tassel_2(&self) -> bool {
                *self == Tassel::Tassel2
            }
            #[doc = "Timer A clock source select: 3 - INCLK"]
            #[inline(always)]
            pub fn is_tassel_3(&self) -> bool {
                *self == Tassel::Tassel3
            }
        }
        #[doc = "Field `TASSEL` writer - Timer A clock source select 1"]
        pub type TasselW<'a, REG> = crate::FieldWriter<'a, REG, 2, Tassel, crate::Safe>;
        impl<'a, REG> TasselW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Timer A clock source select: 0 - TACLK"]
            #[inline(always)]
            pub fn tassel_0(self) -> &'a mut crate::W<REG> {
                self.variant(Tassel::Tassel0)
            }
            #[doc = "Timer A clock source select: 1 - ACLK"]
            #[inline(always)]
            pub fn tassel_1(self) -> &'a mut crate::W<REG> {
                self.variant(Tassel::Tassel1)
            }
            #[doc = "Timer A clock source select: 2 - SMCLK"]
            #[inline(always)]
            pub fn tassel_2(self) -> &'a mut crate::W<REG> {
                self.variant(Tassel::Tassel2)
            }
            #[doc = "Timer A clock source select: 3 - INCLK"]
            #[inline(always)]
            pub fn tassel_3(self) -> &'a mut crate::W<REG> {
                self.variant(Tassel::Tassel3)
            }
        }
        impl R {
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&self) -> TaifgR {
                TaifgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&self) -> TaieR {
                TaieR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&self) -> TaclrR {
                TaclrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&self) -> McR {
                McR::new(((self.bits >> 4) & 3) as u8)
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&self) -> IdR {
                IdR::new(((self.bits >> 6) & 3) as u8)
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&self) -> TasselR {
                TasselR::new(((self.bits >> 8) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Timer A counter interrupt flag"]
            #[inline(always)]
            pub fn taifg(&mut self) -> TaifgW<'_, TactlSpec> {
                TaifgW::new(self, 0)
            }
            #[doc = "Bit 1 - Timer A counter interrupt enable"]
            #[inline(always)]
            pub fn taie(&mut self) -> TaieW<'_, TactlSpec> {
                TaieW::new(self, 1)
            }
            #[doc = "Bit 2 - Timer A counter clear"]
            #[inline(always)]
            pub fn taclr(&mut self) -> TaclrW<'_, TactlSpec> {
                TaclrW::new(self, 2)
            }
            #[doc = "Bits 4:5 - Timer A mode control 1"]
            #[inline(always)]
            pub fn mc(&mut self) -> McW<'_, TactlSpec> {
                McW::new(self, 4)
            }
            #[doc = "Bits 6:7 - Timer A clock input divider 1"]
            #[inline(always)]
            pub fn id(&mut self) -> IdW<'_, TactlSpec> {
                IdW::new(self, 6)
            }
            #[doc = "Bits 8:9 - Timer A clock source select 1"]
            #[inline(always)]
            pub fn tassel(&mut self) -> TasselW<'_, TactlSpec> {
                TasselW::new(self, 8)
            }
        }
        #[doc = "Timer A Control\n\nYou can [`read`](crate::Reg::read) this register and get [`tactl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tactl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TactlSpec;
        impl crate::RegisterSpec for TactlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`tactl::R`](R) reader structure"]
        impl crate::Readable for TactlSpec {}
        #[doc = "`write(|w| ..)` method takes [`tactl::W`](W) writer structure"]
        impl crate::Writable for TactlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TACTL to value 0"]
        impl crate::Resettable for TactlSpec {}
    }
    #[doc = "TACCTL0 (rw) register accessor: Timer A Capture/Compare Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`tacctl0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tacctl0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tacctl0`] module"]
    #[doc(alias = "TACCTL0")]
    pub type Tacctl0 = crate::Reg<tacctl0::Tacctl0Spec>;
    #[doc = "Timer A Capture/Compare Control 0"]
    pub mod tacctl0 {
        #[doc = "Register `TACCTL0` reader"]
        pub type R = crate::R<Tacctl0Spec>;
        #[doc = "Register `TACCTL0` writer"]
        pub type W = crate::W<Tacctl0Spec>;
        #[doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
        pub type CcifgR = crate::BitReader;
        #[doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
        pub type CcifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COV` reader - Capture/compare overflow flag"]
        pub type CovR = crate::BitReader;
        #[doc = "Field `COV` writer - Capture/compare overflow flag"]
        pub type CovW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
        pub type OutR = crate::BitReader;
        #[doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
        pub type OutW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CCI` reader - Capture input signal (read)"]
        pub type CciR = crate::BitReader;
        #[doc = "Field `CCI` writer - Capture input signal (read)"]
        pub type CciW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
        pub type CcieR = crate::BitReader;
        #[doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
        pub type CcieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Output mode 2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Outmod {
            #[doc = "0: PWM output mode: 0 - output only"]
            Outmod0 = 0,
            #[doc = "1: PWM output mode: 1 - set"]
            Outmod1 = 1,
            #[doc = "2: PWM output mode: 2 - PWM toggle/reset"]
            Outmod2 = 2,
            #[doc = "3: PWM output mode: 3 - PWM set/reset"]
            Outmod3 = 3,
            #[doc = "4: PWM output mode: 4 - toggle"]
            Outmod4 = 4,
            #[doc = "5: PWM output mode: 5 - Reset"]
            Outmod5 = 5,
            #[doc = "6: PWM output mode: 6 - PWM toggle/set"]
            Outmod6 = 6,
            #[doc = "7: PWM output mode: 7 - PWM reset/set"]
            Outmod7 = 7,
        }
        impl From<Outmod> for u8 {
            #[inline(always)]
            fn from(variant: Outmod) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Outmod {
            type Ux = u8;
        }
        impl crate::IsEnum for Outmod {}
        #[doc = "Field `OUTMOD` reader - Output mode 2"]
        pub type OutmodR = crate::FieldReader<Outmod>;
        impl OutmodR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Outmod {
                match self.bits {
                    0 => Outmod::Outmod0,
                    1 => Outmod::Outmod1,
                    2 => Outmod::Outmod2,
                    3 => Outmod::Outmod3,
                    4 => Outmod::Outmod4,
                    5 => Outmod::Outmod5,
                    6 => Outmod::Outmod6,
                    7 => Outmod::Outmod7,
                    _ => unreachable!(),
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == Outmod::Outmod0
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == Outmod::Outmod1
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == Outmod::Outmod2
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == Outmod::Outmod3
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == Outmod::Outmod4
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == Outmod::Outmod5
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == Outmod::Outmod6
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == Outmod::Outmod7
            }
        }
        #[doc = "Field `OUTMOD` writer - Output mode 2"]
        pub type OutmodW<'a, REG> = crate::FieldWriter<'a, REG, 3, Outmod, crate::Safe>;
        impl<'a, REG> OutmodW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod7)
            }
        }
        #[doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
        pub type CapR = crate::BitReader;
        #[doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
        pub type CapW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SCCI` reader - Latched capture signal (read)"]
        pub type ScciR = crate::BitReader;
        #[doc = "Field `SCCI` writer - Latched capture signal (read)"]
        pub type ScciW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SCS` reader - Capture sychronize"]
        pub type ScsR = crate::BitReader;
        #[doc = "Field `SCS` writer - Capture sychronize"]
        pub type ScsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Capture input select 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ccis {
            #[doc = "0: Capture input select: 0 - CCIxA"]
            Ccis0 = 0,
            #[doc = "1: Capture input select: 1 - CCIxB"]
            Ccis1 = 1,
            #[doc = "2: Capture input select: 2 - GND"]
            Ccis2 = 2,
            #[doc = "3: Capture input select: 3 - Vcc"]
            Ccis3 = 3,
        }
        impl From<Ccis> for u8 {
            #[inline(always)]
            fn from(variant: Ccis) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ccis {
            type Ux = u8;
        }
        impl crate::IsEnum for Ccis {}
        #[doc = "Field `CCIS` reader - Capture input select 1"]
        pub type CcisR = crate::FieldReader<Ccis>;
        impl CcisR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ccis {
                match self.bits {
                    0 => Ccis::Ccis0,
                    1 => Ccis::Ccis1,
                    2 => Ccis::Ccis2,
                    3 => Ccis::Ccis3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == Ccis::Ccis0
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == Ccis::Ccis1
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == Ccis::Ccis2
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == Ccis::Ccis3
            }
        }
        #[doc = "Field `CCIS` writer - Capture input select 1"]
        pub type CcisW<'a, REG> = crate::FieldWriter<'a, REG, 2, Ccis, crate::Safe>;
        impl<'a, REG> CcisW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis3)
            }
        }
        #[doc = "Capture mode 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cm {
            #[doc = "0: Capture mode: 0 - disabled"]
            Cm0 = 0,
            #[doc = "1: Capture mode: 1 - pos. edge"]
            Cm1 = 1,
            #[doc = "2: Capture mode: 1 - neg. edge"]
            Cm2 = 2,
            #[doc = "3: Capture mode: 1 - both edges"]
            Cm3 = 3,
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(variant: Cm) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cm {
            type Ux = u8;
        }
        impl crate::IsEnum for Cm {}
        #[doc = "Field `CM` reader - Capture mode 1"]
        pub type CmR = crate::FieldReader<Cm>;
        impl CmR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cm {
                match self.bits {
                    0 => Cm::Cm0,
                    1 => Cm::Cm1,
                    2 => Cm::Cm2,
                    3 => Cm::Cm3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == Cm::Cm0
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == Cm::Cm1
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == Cm::Cm2
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == Cm::Cm3
            }
        }
        #[doc = "Field `CM` writer - Capture mode 1"]
        pub type CmW<'a, REG> = crate::FieldWriter<'a, REG, 2, Cm, crate::Safe>;
        impl<'a, REG> CmW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm3)
            }
        }
        impl R {
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CcifgR {
                CcifgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> CovR {
                CovR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OutR {
                OutR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CciR {
                CciR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CcieR {
                CcieR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CapR {
                CapR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> ScciR {
                ScciR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> ScsR {
                ScsR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CcisR {
                CcisR::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CmR {
                CmR::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> CcifgW<'_, Tacctl0Spec> {
                CcifgW::new(self, 0)
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> CovW<'_, Tacctl0Spec> {
                CovW::new(self, 1)
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> OutW<'_, Tacctl0Spec> {
                OutW::new(self, 2)
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> CciW<'_, Tacctl0Spec> {
                CciW::new(self, 3)
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> CcieW<'_, Tacctl0Spec> {
                CcieW::new(self, 4)
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> OutmodW<'_, Tacctl0Spec> {
                OutmodW::new(self, 5)
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> CapW<'_, Tacctl0Spec> {
                CapW::new(self, 8)
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> ScciW<'_, Tacctl0Spec> {
                ScciW::new(self, 10)
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> ScsW<'_, Tacctl0Spec> {
                ScsW::new(self, 11)
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> CcisW<'_, Tacctl0Spec> {
                CcisW::new(self, 12)
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> CmW<'_, Tacctl0Spec> {
                CmW::new(self, 14)
            }
        }
        #[doc = "Timer A Capture/Compare Control 0\n\nYou can [`read`](crate::Reg::read) this register and get [`tacctl0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tacctl0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tacctl0Spec;
        impl crate::RegisterSpec for Tacctl0Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`tacctl0::R`](R) reader structure"]
        impl crate::Readable for Tacctl0Spec {}
        #[doc = "`write(|w| ..)` method takes [`tacctl0::W`](W) writer structure"]
        impl crate::Writable for Tacctl0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TACCTL0 to value 0"]
        impl crate::Resettable for Tacctl0Spec {}
    }
    #[doc = "TACCTL1 (rw) register accessor: Timer A Capture/Compare Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`tacctl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tacctl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tacctl1`] module"]
    #[doc(alias = "TACCTL1")]
    pub type Tacctl1 = crate::Reg<tacctl1::Tacctl1Spec>;
    #[doc = "Timer A Capture/Compare Control 1"]
    pub mod tacctl1 {
        #[doc = "Register `TACCTL1` reader"]
        pub type R = crate::R<Tacctl1Spec>;
        #[doc = "Register `TACCTL1` writer"]
        pub type W = crate::W<Tacctl1Spec>;
        #[doc = "Field `CCIFG` reader - Capture/compare interrupt flag"]
        pub type CcifgR = crate::BitReader;
        #[doc = "Field `CCIFG` writer - Capture/compare interrupt flag"]
        pub type CcifgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `COV` reader - Capture/compare overflow flag"]
        pub type CovR = crate::BitReader;
        #[doc = "Field `COV` writer - Capture/compare overflow flag"]
        pub type CovW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUT` reader - PWM Output signal if output mode 0"]
        pub type OutR = crate::BitReader;
        #[doc = "Field `OUT` writer - PWM Output signal if output mode 0"]
        pub type OutW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CCI` reader - Capture input signal (read)"]
        pub type CciR = crate::BitReader;
        #[doc = "Field `CCI` writer - Capture input signal (read)"]
        pub type CciW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CCIE` reader - Capture/compare interrupt enable"]
        pub type CcieR = crate::BitReader;
        #[doc = "Field `CCIE` writer - Capture/compare interrupt enable"]
        pub type CcieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Output mode 2\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Outmod {
            #[doc = "0: PWM output mode: 0 - output only"]
            Outmod0 = 0,
            #[doc = "1: PWM output mode: 1 - set"]
            Outmod1 = 1,
            #[doc = "2: PWM output mode: 2 - PWM toggle/reset"]
            Outmod2 = 2,
            #[doc = "3: PWM output mode: 3 - PWM set/reset"]
            Outmod3 = 3,
            #[doc = "4: PWM output mode: 4 - toggle"]
            Outmod4 = 4,
            #[doc = "5: PWM output mode: 5 - Reset"]
            Outmod5 = 5,
            #[doc = "6: PWM output mode: 6 - PWM toggle/set"]
            Outmod6 = 6,
            #[doc = "7: PWM output mode: 7 - PWM reset/set"]
            Outmod7 = 7,
        }
        impl From<Outmod> for u8 {
            #[inline(always)]
            fn from(variant: Outmod) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Outmod {
            type Ux = u8;
        }
        impl crate::IsEnum for Outmod {}
        #[doc = "Field `OUTMOD` reader - Output mode 2"]
        pub type OutmodR = crate::FieldReader<Outmod>;
        impl OutmodR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Outmod {
                match self.bits {
                    0 => Outmod::Outmod0,
                    1 => Outmod::Outmod1,
                    2 => Outmod::Outmod2,
                    3 => Outmod::Outmod3,
                    4 => Outmod::Outmod4,
                    5 => Outmod::Outmod5,
                    6 => Outmod::Outmod6,
                    7 => Outmod::Outmod7,
                    _ => unreachable!(),
                }
            }
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn is_outmod_0(&self) -> bool {
                *self == Outmod::Outmod0
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn is_outmod_1(&self) -> bool {
                *self == Outmod::Outmod1
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn is_outmod_2(&self) -> bool {
                *self == Outmod::Outmod2
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn is_outmod_3(&self) -> bool {
                *self == Outmod::Outmod3
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn is_outmod_4(&self) -> bool {
                *self == Outmod::Outmod4
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn is_outmod_5(&self) -> bool {
                *self == Outmod::Outmod5
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn is_outmod_6(&self) -> bool {
                *self == Outmod::Outmod6
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn is_outmod_7(&self) -> bool {
                *self == Outmod::Outmod7
            }
        }
        #[doc = "Field `OUTMOD` writer - Output mode 2"]
        pub type OutmodW<'a, REG> = crate::FieldWriter<'a, REG, 3, Outmod, crate::Safe>;
        impl<'a, REG> OutmodW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "PWM output mode: 0 - output only"]
            #[inline(always)]
            pub fn outmod_0(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod0)
            }
            #[doc = "PWM output mode: 1 - set"]
            #[inline(always)]
            pub fn outmod_1(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod1)
            }
            #[doc = "PWM output mode: 2 - PWM toggle/reset"]
            #[inline(always)]
            pub fn outmod_2(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod2)
            }
            #[doc = "PWM output mode: 3 - PWM set/reset"]
            #[inline(always)]
            pub fn outmod_3(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod3)
            }
            #[doc = "PWM output mode: 4 - toggle"]
            #[inline(always)]
            pub fn outmod_4(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod4)
            }
            #[doc = "PWM output mode: 5 - Reset"]
            #[inline(always)]
            pub fn outmod_5(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod5)
            }
            #[doc = "PWM output mode: 6 - PWM toggle/set"]
            #[inline(always)]
            pub fn outmod_6(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod6)
            }
            #[doc = "PWM output mode: 7 - PWM reset/set"]
            #[inline(always)]
            pub fn outmod_7(self) -> &'a mut crate::W<REG> {
                self.variant(Outmod::Outmod7)
            }
        }
        #[doc = "Field `CAP` reader - Capture mode: 1 /Compare mode : 0"]
        pub type CapR = crate::BitReader;
        #[doc = "Field `CAP` writer - Capture mode: 1 /Compare mode : 0"]
        pub type CapW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SCCI` reader - Latched capture signal (read)"]
        pub type ScciR = crate::BitReader;
        #[doc = "Field `SCCI` writer - Latched capture signal (read)"]
        pub type ScciW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SCS` reader - Capture sychronize"]
        pub type ScsR = crate::BitReader;
        #[doc = "Field `SCS` writer - Capture sychronize"]
        pub type ScsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Capture input select 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Ccis {
            #[doc = "0: Capture input select: 0 - CCIxA"]
            Ccis0 = 0,
            #[doc = "1: Capture input select: 1 - CCIxB"]
            Ccis1 = 1,
            #[doc = "2: Capture input select: 2 - GND"]
            Ccis2 = 2,
            #[doc = "3: Capture input select: 3 - Vcc"]
            Ccis3 = 3,
        }
        impl From<Ccis> for u8 {
            #[inline(always)]
            fn from(variant: Ccis) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Ccis {
            type Ux = u8;
        }
        impl crate::IsEnum for Ccis {}
        #[doc = "Field `CCIS` reader - Capture input select 1"]
        pub type CcisR = crate::FieldReader<Ccis>;
        impl CcisR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Ccis {
                match self.bits {
                    0 => Ccis::Ccis0,
                    1 => Ccis::Ccis1,
                    2 => Ccis::Ccis2,
                    3 => Ccis::Ccis3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn is_ccis_0(&self) -> bool {
                *self == Ccis::Ccis0
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn is_ccis_1(&self) -> bool {
                *self == Ccis::Ccis1
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn is_ccis_2(&self) -> bool {
                *self == Ccis::Ccis2
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn is_ccis_3(&self) -> bool {
                *self == Ccis::Ccis3
            }
        }
        #[doc = "Field `CCIS` writer - Capture input select 1"]
        pub type CcisW<'a, REG> = crate::FieldWriter<'a, REG, 2, Ccis, crate::Safe>;
        impl<'a, REG> CcisW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Capture input select: 0 - CCIxA"]
            #[inline(always)]
            pub fn ccis_0(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis0)
            }
            #[doc = "Capture input select: 1 - CCIxB"]
            #[inline(always)]
            pub fn ccis_1(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis1)
            }
            #[doc = "Capture input select: 2 - GND"]
            #[inline(always)]
            pub fn ccis_2(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis2)
            }
            #[doc = "Capture input select: 3 - Vcc"]
            #[inline(always)]
            pub fn ccis_3(self) -> &'a mut crate::W<REG> {
                self.variant(Ccis::Ccis3)
            }
        }
        #[doc = "Capture mode 1\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum Cm {
            #[doc = "0: Capture mode: 0 - disabled"]
            Cm0 = 0,
            #[doc = "1: Capture mode: 1 - pos. edge"]
            Cm1 = 1,
            #[doc = "2: Capture mode: 1 - neg. edge"]
            Cm2 = 2,
            #[doc = "3: Capture mode: 1 - both edges"]
            Cm3 = 3,
        }
        impl From<Cm> for u8 {
            #[inline(always)]
            fn from(variant: Cm) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for Cm {
            type Ux = u8;
        }
        impl crate::IsEnum for Cm {}
        #[doc = "Field `CM` reader - Capture mode 1"]
        pub type CmR = crate::FieldReader<Cm>;
        impl CmR {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Cm {
                match self.bits {
                    0 => Cm::Cm0,
                    1 => Cm::Cm1,
                    2 => Cm::Cm2,
                    3 => Cm::Cm3,
                    _ => unreachable!(),
                }
            }
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn is_cm_0(&self) -> bool {
                *self == Cm::Cm0
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn is_cm_1(&self) -> bool {
                *self == Cm::Cm1
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn is_cm_2(&self) -> bool {
                *self == Cm::Cm2
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn is_cm_3(&self) -> bool {
                *self == Cm::Cm3
            }
        }
        #[doc = "Field `CM` writer - Capture mode 1"]
        pub type CmW<'a, REG> = crate::FieldWriter<'a, REG, 2, Cm, crate::Safe>;
        impl<'a, REG> CmW<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Capture mode: 0 - disabled"]
            #[inline(always)]
            pub fn cm_0(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm0)
            }
            #[doc = "Capture mode: 1 - pos. edge"]
            #[inline(always)]
            pub fn cm_1(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm1)
            }
            #[doc = "Capture mode: 1 - neg. edge"]
            #[inline(always)]
            pub fn cm_2(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm2)
            }
            #[doc = "Capture mode: 1 - both edges"]
            #[inline(always)]
            pub fn cm_3(self) -> &'a mut crate::W<REG> {
                self.variant(Cm::Cm3)
            }
        }
        impl R {
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&self) -> CcifgR {
                CcifgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&self) -> CovR {
                CovR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&self) -> OutR {
                OutR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&self) -> CciR {
                CciR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&self) -> CcieR {
                CcieR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&self) -> OutmodR {
                OutmodR::new(((self.bits >> 5) & 7) as u8)
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&self) -> CapR {
                CapR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&self) -> ScciR {
                ScciR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&self) -> ScsR {
                ScsR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&self) -> CcisR {
                CcisR::new(((self.bits >> 12) & 3) as u8)
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&self) -> CmR {
                CmR::new(((self.bits >> 14) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - Capture/compare interrupt flag"]
            #[inline(always)]
            pub fn ccifg(&mut self) -> CcifgW<'_, Tacctl1Spec> {
                CcifgW::new(self, 0)
            }
            #[doc = "Bit 1 - Capture/compare overflow flag"]
            #[inline(always)]
            pub fn cov(&mut self) -> CovW<'_, Tacctl1Spec> {
                CovW::new(self, 1)
            }
            #[doc = "Bit 2 - PWM Output signal if output mode 0"]
            #[inline(always)]
            pub fn out(&mut self) -> OutW<'_, Tacctl1Spec> {
                OutW::new(self, 2)
            }
            #[doc = "Bit 3 - Capture input signal (read)"]
            #[inline(always)]
            pub fn cci(&mut self) -> CciW<'_, Tacctl1Spec> {
                CciW::new(self, 3)
            }
            #[doc = "Bit 4 - Capture/compare interrupt enable"]
            #[inline(always)]
            pub fn ccie(&mut self) -> CcieW<'_, Tacctl1Spec> {
                CcieW::new(self, 4)
            }
            #[doc = "Bits 5:7 - Output mode 2"]
            #[inline(always)]
            pub fn outmod(&mut self) -> OutmodW<'_, Tacctl1Spec> {
                OutmodW::new(self, 5)
            }
            #[doc = "Bit 8 - Capture mode: 1 /Compare mode : 0"]
            #[inline(always)]
            pub fn cap(&mut self) -> CapW<'_, Tacctl1Spec> {
                CapW::new(self, 8)
            }
            #[doc = "Bit 10 - Latched capture signal (read)"]
            #[inline(always)]
            pub fn scci(&mut self) -> ScciW<'_, Tacctl1Spec> {
                ScciW::new(self, 10)
            }
            #[doc = "Bit 11 - Capture sychronize"]
            #[inline(always)]
            pub fn scs(&mut self) -> ScsW<'_, Tacctl1Spec> {
                ScsW::new(self, 11)
            }
            #[doc = "Bits 12:13 - Capture input select 1"]
            #[inline(always)]
            pub fn ccis(&mut self) -> CcisW<'_, Tacctl1Spec> {
                CcisW::new(self, 12)
            }
            #[doc = "Bits 14:15 - Capture mode 1"]
            #[inline(always)]
            pub fn cm(&mut self) -> CmW<'_, Tacctl1Spec> {
                CmW::new(self, 14)
            }
        }
        #[doc = "Timer A Capture/Compare Control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`tacctl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tacctl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Tacctl1Spec;
        impl crate::RegisterSpec for Tacctl1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`tacctl1::R`](R) reader structure"]
        impl crate::Readable for Tacctl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`tacctl1::W`](W) writer structure"]
        impl crate::Writable for Tacctl1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TACCTL1 to value 0"]
        impl crate::Resettable for Tacctl1Spec {}
    }
    #[doc = "TAR (rw) register accessor: Timer A Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tar`] module"]
    #[doc(alias = "TAR")]
    pub type Tar = crate::Reg<tar::TarSpec>;
    #[doc = "Timer A Counter Register"]
    pub mod tar {
        #[doc = "Register `TAR` reader"]
        pub type R = crate::R<TarSpec>;
        #[doc = "Register `TAR` writer"]
        pub type W = crate::W<TarSpec>;
        #[doc = "Field `TAR` reader - Timer A Counter Register"]
        pub type TarR = crate::FieldReader<u16>;
        #[doc = "Field `TAR` writer - Timer A Counter Register"]
        pub type TarW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Timer A Counter Register"]
            #[inline(always)]
            pub fn tar(&self) -> TarR {
                TarR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer A Counter Register"]
            #[inline(always)]
            pub fn tar(&mut self) -> TarW<'_, TarSpec> {
                TarW::new(self, 0)
            }
        }
        #[doc = "Timer A Counter Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TarSpec;
        impl crate::RegisterSpec for TarSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`tar::R`](R) reader structure"]
        impl crate::Readable for TarSpec {}
        #[doc = "`write(|w| ..)` method takes [`tar::W`](W) writer structure"]
        impl crate::Writable for TarSpec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets TAR to value 0"]
        impl crate::Resettable for TarSpec {}
    }
    #[doc = "TACCR0 (rw) register accessor: Timer A Capture/Compare 0\n\nYou can [`read`](crate::Reg::read) this register and get [`taccr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taccr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@taccr0`] module"]
    #[doc(alias = "TACCR0")]
    pub type Taccr0 = crate::Reg<taccr0::Taccr0Spec>;
    #[doc = "Timer A Capture/Compare 0"]
    pub mod taccr0 {
        #[doc = "Register `TACCR0` reader"]
        pub type R = crate::R<Taccr0Spec>;
        #[doc = "Register `TACCR0` writer"]
        pub type W = crate::W<Taccr0Spec>;
        #[doc = "Field `TACCR0` reader - Timer A Capture/Compare 0"]
        pub type Taccr0R = crate::FieldReader<u16>;
        #[doc = "Field `TACCR0` writer - Timer A Capture/Compare 0"]
        pub type Taccr0W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Timer A Capture/Compare 0"]
            #[inline(always)]
            pub fn taccr0(&self) -> Taccr0R {
                Taccr0R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer A Capture/Compare 0"]
            #[inline(always)]
            pub fn taccr0(&mut self) -> Taccr0W<'_, Taccr0Spec> {
                Taccr0W::new(self, 0)
            }
        }
        #[doc = "Timer A Capture/Compare 0\n\nYou can [`read`](crate::Reg::read) this register and get [`taccr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taccr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Taccr0Spec;
        impl crate::RegisterSpec for Taccr0Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`taccr0::R`](R) reader structure"]
        impl crate::Readable for Taccr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`taccr0::W`](W) writer structure"]
        impl crate::Writable for Taccr0Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets TACCR0 to value 0"]
        impl crate::Resettable for Taccr0Spec {}
    }
    #[doc = "TACCR1 (rw) register accessor: Timer A Capture/Compare 1\n\nYou can [`read`](crate::Reg::read) this register and get [`taccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@taccr1`] module"]
    #[doc(alias = "TACCR1")]
    pub type Taccr1 = crate::Reg<taccr1::Taccr1Spec>;
    #[doc = "Timer A Capture/Compare 1"]
    pub mod taccr1 {
        #[doc = "Register `TACCR1` reader"]
        pub type R = crate::R<Taccr1Spec>;
        #[doc = "Register `TACCR1` writer"]
        pub type W = crate::W<Taccr1Spec>;
        #[doc = "Field `TACCR1` reader - Timer A Capture/Compare 1"]
        pub type Taccr1R = crate::FieldReader<u16>;
        #[doc = "Field `TACCR1` writer - Timer A Capture/Compare 1"]
        pub type Taccr1W<'a, REG> = crate::FieldWriter<'a, REG, 16, u16, crate::Safe>;
        impl R {
            #[doc = "Bits 0:15 - Timer A Capture/Compare 1"]
            #[inline(always)]
            pub fn taccr1(&self) -> Taccr1R {
                Taccr1R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - Timer A Capture/Compare 1"]
            #[inline(always)]
            pub fn taccr1(&mut self) -> Taccr1W<'_, Taccr1Spec> {
                Taccr1W::new(self, 0)
            }
        }
        #[doc = "Timer A Capture/Compare 1\n\nYou can [`read`](crate::Reg::read) this register and get [`taccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`taccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Taccr1Spec;
        impl crate::RegisterSpec for Taccr1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`taccr1::R`](R) reader structure"]
        impl crate::Readable for Taccr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`taccr1::W`](W) writer structure"]
        impl crate::Writable for Taccr1Spec {
            type Safety = crate::Safe;
        }
        #[doc = "`reset()` method sets TACCR1 to value 0"]
        impl crate::Resettable for Taccr1Spec {}
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "SPECIAL_FUNCTION"]
    pub special_function: SpecialFunction,
    #[doc = "PORT_1_2"]
    pub port_1_2: Port1_2,
    #[doc = "ADC10"]
    pub adc10: Adc10,
    #[doc = "SYSTEM_CLOCK"]
    pub system_clock: SystemClock,
    #[doc = "USI"]
    pub usi: Usi,
    #[doc = "CALIBRATION_DATA"]
    pub calibration_data: CalibrationData,
    #[doc = "WATCHDOG_TIMER"]
    pub watchdog_timer: WatchdogTimer,
    #[doc = "FLASH"]
    pub flash: Flash,
    #[doc = "TIMER_A2"]
    pub timer_a2: TimerA2,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            special_function: SpecialFunction::steal(),
            port_1_2: Port1_2::steal(),
            adc10: Adc10::steal(),
            system_clock: SystemClock::steal(),
            usi: Usi::steal(),
            calibration_data: CalibrationData::steal(),
            watchdog_timer: WatchdogTimer::steal(),
            flash: Flash::steal(),
            timer_a2: TimerA2::steal(),
        }
    }
}
